{"./":{"url":"./","title":"简介","keywords":"","body":"TreeviewCopyright © all right reserved, powered by aleen42 简介 1. GitBook 1.1 百度百科 1.2 下载安装 1.3 基本操作 1.4 插件列表 2. Node.js 3. Typora 4. GitHub 5. 免责说明 简介 1. GitBook Document Everything! For you, your users and your team 1.1 百度百科 ​ GitBook是一个基于 Node.js的命令行工具，可使用Github/Git和 Markdown来制作精美的电子书，GitBook 并非关于 Git 的教程。 GitBook支持输出多种文档格式： 静态站点：GitBook默认输出该种格式，生成的静态站点可直接托管搭载Github Pages服务上； PDF：需要安装gitbook-pdf依赖； eBook：需要安装ebook-convert； 单HTML网页：支持将内容输出为单页的HTML，不过一般用在将电子书格式转换为PDF或eBook的中间过程； JSON：一般用于电子书的调试或元数据提取。 使用GitBook制作电子书，必备两个文件：README.md和SUMMARY.md。 1.2 下载安装 ​ 安装GitBook需要先安装Node.js环境，安装Node.js一般会默认安装npm(node包管理工具)，命令行使用npm命令安装GitBook: npm install -g gitbook-cli 命令行执行以下命令可查看GitBook版本信息 gitbook -V 1.3 基本操作 以下均为基本命令（一般不涉及参数），有兴趣可以具体学习。 命令行执行以下命令可查看GitBook帮助 gitbook --help 命令行执行以下命令可查看本地所有安装版本 gitbook ls 命令行执行以下命令可查看本地当前使用版本 gitbook current 命令行执行以下命令可更新版本 gitbook update 命令行执行以下命令可初始化/重新构建一本书籍 gitbook init 命令行执行以下命令可构建书籍 gitbook build 命令行执行以下命令可安装插件 gitbook install 命令行执行以下命令可启动本地服务器 gitbook serve 之后可访问地址：http://localhost:4000 预览书籍 1.4 插件列表 Gitbook默认自带有5个插件： highlight： 代码高亮 search： 导航栏查询功能（不支持中文） sharing：右上角分享功能 font-settings：字体设置（最上方的\"A\"符号） livereload：为GitBook实时重新加载 以下为新增插件： 插件名 引入方式 说明 page-copyright \"page-copyright\" 页面页脚版权说明 hide-element \"hide-element\" 隐藏特定标签 back-to-top-button \"back-to-top-button\" 页面添加返回顶部的按钮 chapter-fold \"chapter-fold\" 导航目录折叠 code \"code\" 代码添加行号&复制按钮 splitter \"splitter\" 侧边栏宽度可调节 search-pro \"-lunr\", \"-search\", \"search-pro\", 高级搜索（支持中文）在使用此插件之前，需要将默认的search和lunr 插件去掉。 custom-favicon \"custom-favicon\" 更换标题栏图标 expandable-chapters \"expandable-chapters\" 可扩展导航章节 klipse \"klipse\" 嵌入类似IDE的功能 github \"github\" 在右上角添加github图标 page-treeview \"page-treeview\" 生成页内目录 2. Node.js Node.js® is a JavaScript runtime built on Chrome's V8 JavaScript engine. 官网地址：https://nodejs.org/en/ 一般对应平台都分为LTS和Current两个版本，建议选取LTS版 下载安装后，打开命令行执行，显示版本号即安装成功 node -v 3. Typora Typora是一款轻便简洁的Markdown编辑器，支持即时渲染技术，这也是与其他Markdown编辑器最显著的区别。即时渲染使得你写Markdown就想是写Word文档一样流畅自如，不像其他编辑器的有编辑栏和显示栏。 官网地址：https://www.typora.io/ 该软件目前支持OS X，Window， Linux，可在官网直接下载安装。 4. GitHub ​ GitHub是一个面向开源及私有软件项目的托管平台，因为只支持git 作为唯一的版本库格式进行托管，故名GitHub。 ​ 作为开源代码库以及版本控制系统，Github拥有超过900万开发者用户。随着越来越多的应用程序转移到了云上，Github已经成为了管理软件开发以及发现已有代码的首选方法。 5. 免责说明 本文档基本基于对网络内容和书籍的摘抄总结，如有侵权，请及时联系。 MU_zjm®Designer, Developer & overall web enthusiastCopyright © MU_zjm all right reserved, powered by MU_zjm!created by MU_zjm 2019-08-28 12:00:00 "},"Java/":{"url":"Java/","title":"Java基础","keywords":"","body":"TreeviewCopyright © all right reserved, powered by aleen42 Java基础 1. 概述 2. JDK 3. Eclipse 4. IDEA Java基础 1. 概述 ​ Java是一门面向对象编程语言，不仅吸收了C++语言的各种优点，还摒弃了C++里难以理解的多继承、指针等概念，因此Java语言具有功能强大和简单易用两个特征。Java语言作为静态面向对象编程语言的代表，极好地实现了面向对象理论，允许程序员以优雅的思维方式进行复杂的编程 。 ​ Java具有简单性、面向对象、分布式、健壮性、安全性、平台独立与可移植性、多线程、动态性等特点 。Java可以编写桌面应用程序、Web应用程序、分布式系统和嵌入式系统应用程序等 。 2. JDK ​ JDK是 Java 语言的软件开发工具包，主要用于移动设备、嵌入式设备上的java应用程序。JDK是整个java开发的核心，它包含了JAVA的运行环境（JVM+Java系统类库）和JAVA工具。 ​ 目前推荐使用JDK8.0以上的版本，以下为下载链接，可选取对应版本下载 https://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html ​ Windows下安装JDK一般需要配置环境变量，网上教程很多，配置项大致如下： JAVA_HOME //新建 //对应JDK安装目录 Path //新增或编辑 ;%JAVA_HOME%\\bin;%JAVA_HOME%\\jre\\bin; CLASSPATH //新建 .;%JAVA_HOME%\\lib;%JAVA_HOME%\\lib\\tools.jar ​ 配置完成后打开命令行输入如下命令可查看版本 >java -version java version \"1.8.0_191\" Java(TM) SE Runtime Environment (build 1.8.0_191-b12) Java HotSpot(TM) 64-Bit Server VM (build 25.191-b12, mixed mode) 3. Eclipse ​ Eclipse 是一个开放源代码的、基于Java的可扩展开发平台。就其本身而言，它只是一个框架和一组服务，用于通过插件组件构建开发环境。 ​ Eclipse是著名的跨平台的自由集成开发环境（IDE）。最初主要用来Java语言开发，通过安装不同的插件Eclipse可以支持不同的计算机语言，比如C++和Python等开发工具。Eclipse的本身只是一个框架平台，但是众多插件的支持使得Eclipse拥有其他功能相对固定的IDE软件很难具有的灵活性。许多软件开发商以Eclipse为框架开发自己的IDE。 ​ Eclipse 最初由OTI和IBM两家公司的IDE产品开发组创建，起始于1999年4月。IBM提供了最初的Eclipse代码基础，包括Platform、JDT 和PDE。Eclipse项目IBM发起，围绕着Eclipse项目已经发展成为了一个庞大的Eclipse联盟，有150多家软件公司参与到Eclipse项目中。 ​ Eclipse是一个开放源码项目，它其实是Visual Age for Java的替代品，其界面跟先前的Visual Age for Java差不多，但由于其开放源码，任何人都可以免费得到，并可以在此基础上开发各自的插件，因此越来越受人们关注。随后还有包括Oracle在内的许多大公司也纷纷加入了该项目，Eclipse的目标是成为可进行任何语言开发的IDE集成者，使用者只需下载各种语言的插件即可。 4. IDEA ​ IDEA 全称 IntelliJ IDEA，是java编程语言开发的集成环境。IntelliJ在业界被公认为最好的java开发工具之一，尤其在智能代码助手、代码自动提示、重构、J2EE支持、各类版本工具(git、svn等)、JUnit、CVS整合、代码分析、 创新的GUI设计等方面的功能可以说是超常的。 ​ IDEA是JetBrains公司的产品，这家公司总部位于捷克共和国的首都布拉格，开发人员以严谨著称的东欧程序员为主。它的旗舰版本还支持HTML，CSS，PHP，MySQL，Python等。免费版只支持Python等少数语言。 MU_zjm®Designer, Developer & overall web enthusiastCopyright © MU_zjm all right reserved, powered by MU_zjm!created by MU_zjm 2019-08-28 12:00:00 "},"Java/Chapter1.html":{"url":"Java/Chapter1.html","title":"第一章：基础知识","keywords":"","body":"第一章：基础知识 MU_zjm®Designer, Developer & overall web enthusiastCopyright © MU_zjm all right reserved, powered by MU_zjm!created by MU_zjm 2019-08-28 12:00:00 "},"DataBase/":{"url":"DataBase/","title":"数据库基础","keywords":"","body":"TreeviewCopyright © all right reserved, powered by aleen42 数据库基础 1. 关系型数据库 2. 标准SQL 3. 非关系型数据库 4. NoSQL 与关系型数据库的区别 4.1 存储方式 4.2 存储结构 4.3 存储规范 4.4 扩展方式 4.4 查询方式 4.5 规范化 4.6 事务性 4.7 读写性能 4.8 授权方式 5. 分布式数据库 数据库基础 ​ 数据库是存放数据的仓库。它的存储空间很大，可以存放百万条、千万条、上亿条数据。但是数据库并不是随意地将数据进行存放，是有一定的规则的，否则查询的效率会很低。当今世界是一个充满着数据的互联网世界，充斥着大量的数据。即这个互联网世界就是数据世界。数据的来源有很多，比如出行记录、消费记录、浏览的网页、发送的消息等等。除了文本类型的数据，图像、音乐、声音都是数据。 ​ 在数据库的发展历史上，数据库先后经历了层次数据库、网状数据库和关系数据库等各个阶段的发展，数据库技术在各个方面的快速的发展。特别是关系型数据库已经成为目前数据库产品中最重要的一员，80年代以来， 几乎所有的数据库厂商新出的数据库产品都支持关系型数据库，即使一些非关系数据库产品也几乎都有支持关系数据库的接口。这主要是传统的关系型数据库可以比较好的解决管理和存储关系型数据的问题。随着云计算的发展和大数据时代的到来，关系型数据库越来越无法满足需要，这主要是由于越来越多的半关系型和非关系型数据需要用数据库进行存储管理，以此同时，分布式技术等新技术的出现也对数据库的技术提出了新的要求，于是越来越多的非关系型数据库就开始出现，这类数据库与传统的关系型数据库在设计和数据结构有了很大的不同， 它们更强调数据库数据的高并发读写和存储大数据，这类数据库一般被称为NoSQL（Not only SQL）数据库。 而传统的关系型数据库在一些传统领域依然保持了强大的生命力。 1. 关系型数据库 ​ 关系型数据库，存储的格式可以直观地反映实体间的关系。关系型数据库和常见的表格比较相似，关系型数据库中表与表之间是有很多复杂的关联关系的。 常见的关系型数据库有Mysql，SqlServer等。在轻量或者小型的应用中，使用不同的关系型数据库对系统的性能影响不大，但是在构建大型应用时，则需要根据应用的业务需求和性能需求，选择合适的关系型数据库。 ​ 关系型数据库对于结构化数据的处理更合适，如学生成绩、地址等，这样的数据一般情况下需要使用结构化的查询，例如join，这样的情况下，关系型数据库就会比NoSQL数据库性能更优，而且精确度更高。由于结构化数据的规模不算太大，数据规模的增长通常也是可预期的，所以针对结构化数据使用关系型数据库更好。关系型数据库十分注意数据操作的事务性、一致性，如果对这方面的要求关系型数据库无疑可以很好的满足。 2. 标准SQL ​ 虽然关系型数据库有很多，但是大多数都遵循SQL（结构化查询语言，Structured Query Language）标准。 常见的操作有查询，新增，更新，删除，求和，排序等。 查询语句：SELECT param FROM table WHERE condition 该语句可以理解为从 table 中查询出满足 condition 条件的字段 param。 新增语句：INSERT INTO table （param1，param2，param3） VALUES （value1，value2，value3） 该语句可以理解为向table中的param1，param2，param3字段中分别插入value1，value2，value3。 更新语句：UPDATE table SET param=new_value WHERE condition 该语句可以理解为将满足condition条件的字段param更新为 new_value 值。 删除语句：DELETE FROM table WHERE condition 该语句可以理解为将满足condition条件的数据全部删除。 去重查询：SELECT DISTINCT param FROM table WHERE condition 该语句可以理解为从表table中查询出满足条件condition的字段param，但是param中重复的值只能出现一次。 排序查询：SELECT param FROM table WHERE condition ORDER BY param1该语句可以理解为从表table 中查询出满足condition条件的param，并且要按照param1升序的顺序进行排序。 总体来说， 数据库的SELECT，INSERT，UPDATE，DELETE对应了我们常用的增删改查四种操作。 3. 非关系型数据库 ​ 随着近些年技术方向的不断拓展，大量的NoSql数据库如MongoDB、Redis、Memcache出于简化数据库结构、避免冗余、影响性能的表连接、摒弃复杂分布式的目的被设计。 ​ 指的是分布式的、非关系型的、不保证遵循ACID原则的数据存储系统。NoSQL数据库技术与CAP理论、一致性哈希算法有密切关系。所谓CAP理论，简单来说就是一个分布式系统不可能满足可用性、一致性与分区容错性这三个要求，一次性满足两种要求是该系统的上限。而一致性哈希算则指的是NoSQL数据库在应用过程中，为满足工作需求而在通常情况下产生的一种数据算法，该算法能有效解决工作方面的诸多问题但也存在弊端，即工作完成质量会随着节点的变化而产生波动，当节点过多时，相关工作结果就无法那么准确。这一问题使整个系统的工作效率受到影响，导致整个数据库系统的数据乱码与出错率大大提高，甚至会出现数据节点的内容迁移，产生错误的代码信息。但尽管如此，NoSQL数据库技术还是具有非常明显的应用优势，如数据库结构相对简单，在大数据量下的读写性能好；能满足随时存储自定义数据格式需求，非常适用于大数据处理工作。 ​ NoSQL数据库适合追求速度和可扩展性、业务多变的应用场景。对于非结构化数据的处理更合适，如文章、评论，这些数据如全文搜索、机器学习通常只用于模糊处理，并不需要像结构化数据一样，进行精确查询，而且这类数据的数据规模往往是海量的，数据规模的增长往往也是不可能预期的，而NoSQL数据库的扩展能力几乎也是无限的，所以NoSQL数据库可以很好的满足这一类数据的存储。NoSQL数据库利用key-value可以大量的获取大量的非结构化数据，并且数据的获取效率很高，但用它查询结构化数据效果就比较差。 ​ 目前NoSQL数据库仍然没有一个统一的标准，它现在有四种大的分类： （1）键值对存储（key-value）：代表软件Redis，它的优点能够进行数据的快速查询，而缺点是需要存储数据之间的关系。 （2）列存储：代表软件Hbase，它的优点是对数据能快速查询，数据存储的扩展性强。而缺点是数据库的功能有局限性。 （3）文档数据库存储：代表软件MongoDB，它的优点是对数据结构要求不特别的严格。而缺点是查询性的性能不好，同时缺少一种统一查询语言。 （4）图形数据库存储：代表软件InfoGrid，它的优点可以方便的利用图结构相关算法进行计算。而缺点是要想得到结果必须进行整个图的计算，而且遇到不适合的数据模型时，图形数据库很难使用。 4. NoSQL 与关系型数据库的区别 4.1 存储方式 ​ 传统的关系型数据库采用表格的储存方式， 数据以行和列的方式进行存储，要读取和查询都十分方便。而非关系型数据不适合这样的表格存储方式，通常以数据集的方式，大量的数据集中存储在一起，类似于键值对、图结构或者文档。 4.2 存储结构 ​ 关系型数据库按照结构化的方法存储数据， 每个数据表都必须对各个字段定义好（也就是先定义好表的结构），再根据表的结构存入数据，这样做的好处就是由于数据的形式和内容在存入数据之前就已经定义好了，所以整个数据表的可靠性和稳定性都比较高，但带来的问题就是一旦存入数据后，如果需要修改数据表的结构就会十分困难。而NoSQL数据库由于面对的是大量非结构化的数据的存储，它采用的是动态结构，对于数据类型和结构的改变非常的适应，可以根据数据存储的需要灵活的改变数据库的结构。 4.3 存储规范 ​ 关系型数据库为了避免重复、规范化数据以及充分利用好存储空间，把数据按照最小关系表的形式进行存储，这样数据管理的就可以变得很清晰、一目了然，当然这主要是一张数据表的情况。如果是多张表情况就不一样了，由于数据涉及到多张数据表，数据表之间存在着复杂的关系，随着数据表数量的增加，数据管理会越来越复杂。而NoSQL数据库的数据存储方式是用平面数据集的方式集中存放，虽然会存在数据被重复存储，从而造成存储空间被浪费的问题（从当前的计算机硬件的发展来看，这样的存储空间浪费的问题微不足道），但是由于基本上单个数据库都是采用单独存放的形式，很少采用分割存放的方式，所以这样数据往往能存成一个整体，这对于数据的读写提供了极大的方便。 4.4 扩展方式 ​ 当前社会和科学飞速发展，要支持日益增长的数据库存储需求当然要求数据库有良好的扩展性能，并且要求数据库支持更多数据并发量，扩展方式是NoSQL数据库与关系型数据库差别最大的地方，由于关系型数据库将数据存储在数据表中，数据操作的瓶颈出现在多张数据表的操作中，而且数据表越多这个问题越严重，如果要缓解这个问题，只能提高处理能力，也就是选择速度更快性能更高的计算机，这样的方法虽然可以一定的拓展空间，但这样的拓展空间一定有非常有限的，也就是关系型数据库只具备纵向扩展能力。而NoSQL数据库由于使用的是数据集的存储方式，它的存储方式一定是分布式的，它可以采用横向的方式来开展数据库，也就是可以添加更多数据库服务器到资源池，然后由这些增加的服务器来负担数据量增加的开销。 4.4 查询方式 ​ 关系型数据库采用结构化查询语言（即SQL）来对数据库进行查询，SQL早已获得了各个数据库厂商的支持，成为数据库行业的标准，它能够支持数据库的CRUD（增加，查询，更新，删除）操作，具有非常强大的功能，SQL可以采用类似索引的方法来加快查询操作。NoSQL数据库使用的是非结构化查询语言（UnQL），它以数据集（像文档）为单位来管理和操作数据，由于它没有一个统一的标准，所以每个数据库厂商提供产品标准是不一样的，NoSQL中的文档Id与关系型表中主键的概念类似，NoSQL数据库采用的数据访问模式相对SQL更简单而精确。 4.5 规范化 ​ 在数据库的设计开发过程中开发人员通常会面对同时需要对一个或者多个数据实体（包括数组、列表和嵌套数据）进行操作，这样在关系型数据库中，一个数据实体一般首先要分割成多个部分，然后再对分割的部分进行规范化，规范化以后再分别存入到多张关系型数据表中，这是一个复杂的过程。好消息是随着软件技术的发展，相当多的软件开发平台都提供一些简单的解决方法，例如，可以利用ORM层（也就是对象关系映射）来将数据库中对象模型映射到基于SQL的关系型数据库中去以及进行不同类型系统的数据之间的转换。对于NoSQL数据库则没有这方面的问题，它不需要规范化数据，它通常是在一个单独的存储单元中存入一个复杂的数据实体。 4.6 事务性 ​ 关系型数据库强调ACID规则（原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）、持久性（Durability）），可以满足对事务性要求较高或者需要进行复杂数据查询的数据操作，而且可以充分满足数据库操作的高性能和操作稳定性的要求。并且关系型数据库十分强调数据的强一致性，对于事务的操作有很好的支持。关系型数据库可以控制事务原子性细粒度，并且一旦操作有误或者有需要，可以马上回滚事务。而NoSQL数据库强调BASE原则（基本可用（Basically Availble）、软状态（Soft-state）、最终一致性（Eventual Consistency）），它减少了对数据的强一致性支持，从而获得了基本一致性和柔性可靠性，并且利用以上的特性达到了高可靠性和高性能，最终达到了数据的最终一致性。NoSQL数据库虽然对于事务操作也可以使用，但由于它是一种基于节点的分布式数据库，对于事务的操作不能很好的支持，也很难满足其全部的需求，所以NoSQL数据库的性能和优点更多的体现在大数据的处理和数据库的扩展方面。 4.7 读写性能 ​ 关系型数据库十分强调数据的一致性，并为此降低读写性能付出了巨大的代价，虽然关系型数据库存储数据和处理数据的可靠性很不错，但一旦面对海量数据的处理的时候效率就会变得很差，特别是遇到高并发读写的时候性能就会下降的非常厉害。而NoSQL数据库相对关系型数据库优势最大的恰恰是应对大数据方面，也就是对于大量的每天都产生非结构化的数据能够高性能的读写，这是因为NoSQL数据库是按key-value类型进行存储的，以数据集的方式存储的，因此无论是扩展还是读写都非常容易，并且NoSQL数据库不需要关系型数据库繁琐的解析，所以NoSQL数据库大数据管理、检索、读写、分析以及可视化方面具有关系型数据库不可比拟的优势。 4.8 授权方式 ​ 关系型数据库常见的有Oracle，SQLServer，DB2，Mysql，除了Mysql大多数的关系型数据库如果要使用都需要支付一笔价格高昂的费用，即使是免费的Mysql性能也受到了诸多的限制。而对于NoSQL数据库，比较主流的有redis，HBase，MongoDb，memcache等产品，通常都采用开源的方式，不需要像关系型数据库那样，需要一笔高昂的花费。 5. 分布式数据库 ​ 所谓的分布式数据库技术，就是结合了数据库技术与分布式技术的一种结合。具体指的是把那些在地理意义上分散开的各个数据库节点，但在计算机系统逻辑上又是属于同一个系统的数据结合起来的一种数据库技术。既有着数据库间的协调性也有着数据的分布性。这个系统并不注重系统的集中控制，而是注重每个数据库节点的自治性，此外为了让程序员能够在编写程序时可以减轻工作量以及系统出错的可能性，一般都是完全不考虑数据的分布情况，这样的结果就使得系统数据的分布情况一直保持着透明性。 ​ 数据独立性概念在分布式数据库管理系统中同样是十分重要的一环，但是不仅如此，分布式数据管理系统还增加了一个叫分布式透明性的新概念。这个新概念的作用是让数据进行转移时使程序正确性不受影响，就像数据并没有在编写程序时被分布一样。 ​ 在分布式数据库里，数据冗杂是一种被需要的特性，这点和一般的集中式数据库系统不一样。第一点是为了提高局部的应用性而要在那些被需要的数据库节点复制数据。第二点是因为如果某个数据库节点出现系统错误，在修复好之前，可以通过操作其他的数据库节点里复制好的数据来让系统能够继续使用，提高系统的有效性。 MU_zjm®Designer, Developer & overall web enthusiastCopyright © MU_zjm all right reserved, powered by MU_zjm!created by MU_zjm 2019-08-28 12:00:00 "},"DataBase/MYSQL/":{"url":"DataBase/MYSQL/","title":"MYSQL","keywords":"","body":"MYSQL ​ MySQL是一个关系型数据库管理系统，由瑞典MySQL AB 公司开发，目前属于 Oracle 旗下产品。MySQL 是最流行的关系型数据库管理系统之一，在 WEB 应用方面，MySQL是最好的 RDBMS (Relational Database Management System，关系数据库管理系统) 应用软件之一。 ​ MySQL是一种关系数据库管理系统，关系数据库将数据保存在不同的表中，而不是将所有数据放在一个大仓库内，这样就增加了速度并提高了灵活性。 ​ MySQL所使用的 SQL 语言是用于访问数据库的最常用标准化语言。MySQL 软件采用了双授权政策，分为社区版和商业版，由于其体积小、速度快、总体拥有成本低，尤其是开放源码这一特点，一般中小型网站的开发都选择 MySQL 作为网站数据库。 MU_zjm®Designer, Developer & overall web enthusiastCopyright © MU_zjm all right reserved, powered by MU_zjm!created by MU_zjm 2019-08-28 12:00:00 "},"DataBase/MYSQL/Chapter1.html":{"url":"DataBase/MYSQL/Chapter1.html","title":"第一章：基础知识","keywords":"","body":"第一章：基础知识 MU_zjm®Designer, Developer & overall web enthusiastCopyright © MU_zjm all right reserved, powered by MU_zjm!created by MU_zjm 2019-08-28 12:00:00 "},"Python/":{"url":"Python/","title":"Python基础","keywords":"","body":"TreeviewCopyright © all right reserved, powered by aleen42 Python基础 1. 概述 2. 参考内容 Python基础 1. 概述 ​ Python是一种计算机程序设计语言。是一种面向对象的动态类型语言，最初被设计用于编写自动化脚本(shell)，随着版本的不断更新和语言新功能的添加，越来越多被用于独立的、大型项目的开发。 ​ Python目前存在两个版本，即2.X和3.X两个，这里需要说明的是两个版本并不兼容，且2.X会在2020年后停止维护，因此目前建议初学者从3.X学起，本教程也是3.X版本。 ​ Python 是一门简单易学且功能强大的编程语言。它拥有高效的高级数据结构，并且能够用简单而又高效的方式进行面向对象编程。Python 优雅的语法和动态类型，再结合它的解释性，使其在大多数平台的许多领域成为编写脚本或开发应用程序的理想语言。 ​ 你可以自由地从 Python 官方点: http://www.python.org，以源代码或二进制形式获取 Python 解释器及其标准扩展库，并可以自由的分发。此站点同时也提供了大量的第三方 Python 模块、程序和工具，及其附加文档。 ​ 你可以很容易的使用 C 或 C++（其他可以通过 C 调用的语言）为 Python 解释器扩展新函数和数据类型。Python 还可以被用作定制应用程序的一门扩展语言。 2. 参考内容 《菜鸟教程/Python3教程》 《Python基础教程（第三版）》[挪] Magnus Lie Hetland 著 袁国忠 译 MU_zjm®Designer, Developer & overall web enthusiastCopyright © MU_zjm all right reserved, powered by MU_zjm!created by MU_zjm 2019-08-28 12:00:00 "},"Python/Chapter1.html":{"url":"Python/Chapter1.html","title":"第一章：基础知识","keywords":"","body":"TreeviewCopyright © all right reserved, powered by aleen42 第一章：基础知识 一：编码格式 二：python保留字 三：标识符 四：注释 五：行与缩进 六：多行语句 七：空行 八：同一行显示多条语句 九：多个语句构成代码组 十：print输出 1.一般打印 2.原样输出 3.多表达式打印 十一：import 与 from...import 十二：builtins 十三：语句和表达式 十四：获取用户输入 十五：赋值魔法 1. 序列解包 2. 链式赋值 3.增强赋值 十六：运行Python脚本 1. 命令提示符运行Python脚本 2. 作为普通程序运行Python 第一章：基础知识 一：编码格式 ​ 默认情况下，Python 3 源码文件以 UTF-8 编码，所有字符串都是 unicode 字符串。 ​ 当然你也可以为源码文件指定特定的编码： # -*- coding:utf-8 -*- ​ 一般情况下，推荐python文件第一行中指定编码格式 二：python保留字 ​ 保留字即关键字，我们不能把它们用作任何标识符名称。Python 的标准库提供了一个 keyword 模块，可以输出当前版本的所有关键字： Python 3.6.3 (v3.6.3:2c5fed8, Oct 3 2017, 18:11:49) [MSC v.1900 64 bit (AMD64)] on win32 Type \"help\", \"copyright\", \"credits\" or \"license\" for more information. >>> import keyword >>> keyword.kwlist ['False', 'None', 'True', 'and', 'as', 'assert', 'break', 'class', 'continue', 'def', 'del', 'elif', 'else', 'except', 'finally', 'for', 'from', 'global', 'if', 'import', 'in', 'is', 'lambda', 'nonlocal', 'not', 'or', 'pass', 'raise', 'return', 'try', 'while', 'with', 'yield'] 三：标识符 第一个字符必须是字母表中字母或下划线 _ 。 标识符的其他的部分由字母、数字和下划线组成。 标识符对大小写敏感。 四：注释 Python中单行注释以 # 开头，实例如下： #!/usr/bin/python3 # 第一个注释 print (\"Hello, Python!\") # 第二个注释 ''' 这是多行注释，用三个单引号 这是多行注释，用三个单引号 这是多行注释，用三个单引号 ''' \"\"\" 这是多行注释，用三个双引号 这是多行注释，用三个双引号 这是多行注释，用三个双引号 \"\"\" 特殊注释： 指定编码格式 # -*- coding:utf-8 -*- 指定python版本 #!/usr/bin/python3 五：行与缩进 python最具特色的就是使用缩进来表示代码块，不需要使用大括号 {} 。 缩进的空格数是可变的，但是同一个代码块的语句必须包含相同的缩进空格数。实例如下： if True: print (\"True\") else: print (\"False\") 六：多行语句 Python 通常是一行写完一条语句，但如果语句很长，我们可以使用反斜杠()来实现多行语句，例如： total = item_one + \\ item_two + \\ item_three 在 [], {}, 或 () 中的多行语句，不需要使用反斜杠()，例如： total = ['item_one', 'item_two', 'item_three', 'item_four', 'item_five'] 七：空行 ​ 函数之间或类的方法之间用空行分隔，表示一段新的代码的开始。类和函数入口之间也用一行空行分隔，以突出函数入口的开始。 ​ 空行与代码缩进不同，空行并不是Python语法的一部分。书写时不插入空行，Python解释器运行也不会出错。但是空行的作用在于分隔两段不同功能或含义的代码，便于日后代码的维护或重构。 ​ 记住：空行也是程序代码的一部分。 八：同一行显示多条语句 Python可以在同一行中使用多条语句，语句之间使用分号(;)分割，以下是一个简单的实例： #!/usr/bin/python3 import sys; x = 'runoob'; sys.stdout.write(x + '\\n') 九：多个语句构成代码组 ​ 缩进相同的一组语句构成一个代码块，我们称之代码组。 ​ 像if、while、def和class这样的复合语句，首行以关键字开始，以冒号( : )结束，该行之后的一行或多行代码构成代码组。 ​ 我们将首行及后面的代码组称为一个子句(clause)。 ​ 如下实例： if expression : suite elif expression : suite else : suite 十：print输出 1.一般打印 print 默认输出是换行的，如果要实现不换行可自定义结束字符串，以替换默认的换行符。例如：如果将结束字符串指定为空字符串，以后就可以继续打印当前行，即在变量末尾加上 end=\"\"： #!/usr/bin/python3 x=\"a\" y=\"b\" # 换行输出 print( x ) print( y ) print('---------') # 不换行输出 print( x, end=\" \" ) print( y, end=\" \" ) print() 以上实例执行结果为： a b --------- a b 2.原样输出 Python打印所有字符串时，都会用引号将其括起。这是因为Python在打印值时，会保留其在代码中的样子，而不是你希望用户看到的样子。但如果你使用print时，例子如下： Python 3.6.3 (v3.6.3:2c5fed8, Oct 3 2017, 18:11:49) [MSC v.1900 64 bit (AMD64)] on win32 Type \"copyright\", \"credits\" or \"license()\" for more information. >>> 'hello,world!' 'hello,world!' >>> print('hello,world!') hello,world! >>> 'hello,\\nworld!' 'hello,\\nworld!' >>> print('hello,\\nworld!') hello, world! >>> 你还可以使用函数str（一个类）和repr（一个函数）实现类似的效果，如下所示： Python 3.6.3 (v3.6.3:2c5fed8, Oct 3 2017, 18:11:49) [MSC v.1900 64 bit (AMD64)] on win32 Type \"copyright\", \"credits\" or \"license()\" for more information. >>> s = 'hello,\\nworld!' >>> print(str(s)) hello, world! >>> print(repr(s)) 'hello,\\nworld!' >>> 3.多表达式打印 Python支持打印多个表达式，条件是使用逗号分割他们： >>> print('Age:',24) Age: 24 如你所在，在参数之间插入一个空格字符。在你要合并文本和变量值，而又不想使用字符串穿功能时，会更方便： >>> name = 'Gumby' >>> salutation = 'Mr.' >>> greeting = 'Hello,' >>> print(greeting, salutation, name) Hello, Mr. Gumby 如果变量greeting中不包含逗号，该怎么添加逗号？ >>> print(greeting， '， ',salutation, name) SyntaxError: invalid character in identifier 显然上述方法是不可行，因为这将在逗号前添加一个空格，以下是一种解决方案： >>> print(greeting + '， ',salutation, name) Hello， Mr. Gumby 十一：import 与 from...import 可将模块视为扩展，通过将其导入以扩充Python功能 在 python 用 import 或者 from...import 来导入相应的模块。 将整个模块(somemodule)导入，格式为： import somemodule 从某个模块中导入某个函数,格式为： from somemodule import somefunction 从某个模块中导入多个函数,格式为： from somemodule import firstfunc, secondfunc, thirdfunc 将某个模块中的全部函数导入，格式为： from somemodule import * 1. 导入 sys 模块 import sys print('================Python import mode=========================='); print ('命令行参数为:') for i in sys.argv: print (i) print ('\\n python 路径为',sys.path) 2. 导入 sys 模块的 argv,path 成员 from sys import argv,path # 导入特定的成员 print('================python from import===================================') print('path:',path) # 因为已经导入path成员，所以此处引用时不需要加sys.path 如果有两个模块，它们都包含一个函数open，可在导入两模块后通过模块名加点加open即以下格式调用： module1.open(...) module2.open(...) 还有另一种方法，在导入语句末尾添加as子句并指定别名，例子如下： >>> import math as foobar >>> foobar.sqrt(4) 2.0 又或者这样： >>> from math import sqrt as foobar >>> foobar(4) 2.0 十二：builtins 内建命名空间，不需要引入，其中小写字母开头的是BIF(built-in functions)内置函数 Python 3.6.3 (v3.6.3:2c5fed8, Oct 3 2017, 18:11:49) [MSC v.1900 64 bit (AMD64)] on win32 Type \"copyright\", \"credits\" or \"license()\" for more information. >>> dir(__builtins__) ['ArithmeticError', 'AssertionError', 'AttributeError', 'BaseException', 'BlockingIOError', 'BrokenPipeError', 'BufferError', 'BytesWarning', 'ChildProcessError', 'ConnectionAbortedError', 'ConnectionError', 'ConnectionRefusedError', 'ConnectionResetError', 'DeprecationWarning', 'EOFError', 'Ellipsis', 'EnvironmentError', 'Exception', 'False', 'FileExistsError', 'FileNotFoundError', 'FloatingPointError', 'FutureWarning', 'GeneratorExit', 'IOError', 'ImportError', 'ImportWarning', 'IndentationError', 'IndexError', 'InterruptedError', 'IsADirectoryError', 'KeyError', 'KeyboardInterrupt', 'LookupError', 'MemoryError', 'ModuleNotFoundError', 'NameError', 'None', 'NotADirectoryError', 'NotImplemented', 'NotImplementedError', 'OSError', 'OverflowError', 'PendingDeprecationWarning', 'PermissionError', 'ProcessLookupError', 'RecursionError', 'ReferenceError', 'ResourceWarning', 'RuntimeError', 'RuntimeWarning', 'StopAsyncIteration', 'StopIteration', 'SyntaxError', 'SyntaxWarning', 'SystemError', 'SystemExit', 'TabError', 'TimeoutError', 'True', 'TypeError', 'UnboundLocalError', 'UnicodeDecodeError', 'UnicodeEncodeError', 'UnicodeError', 'UnicodeTranslateError', 'UnicodeWarning', 'UserWarning', 'ValueError', 'Warning', 'WindowsError', 'ZeroDivisionError', '__build_class__', '__debug__', '__doc__', '__import__', '__loader__', '__name__', '__package__', '__spec__', 'abs', 'all', 'any', 'ascii', 'bin', 'bool', 'bytearray', 'bytes', 'callable', 'chr', 'classmethod', 'compile', 'complex', 'copyright', 'credits', 'delattr', 'dict', 'dir', 'divmod', 'enumerate', 'eval', 'exec', 'exit', 'filter', 'float', 'format', 'frozenset', 'getattr', 'globals', 'hasattr', 'hash', 'help', 'hex', 'id', 'input', 'int', 'isinstance', 'issubclass', 'iter', 'len', 'license', 'list', 'locals', 'map', 'max', 'memoryview', 'min', 'next', 'object', 'oct', 'open', 'ord', 'pow', 'print', 'property', 'quit', 'range', 'repr', 'reversed', 'round', 'set', 'setattr', 'slice', 'sorted', 'staticmethod', 'str', 'sum', 'super', 'tuple', 'type', 'vars', 'zip'] 十三：语句和表达式 表达式作为程序的一部分，结果是一个值。 语句是让计算机执行特定操作的指示。 通俗的讲：表达式是一些东西，而语句是做一些事情。所有的语句都有一个根本特征：执行修改操作。比如，赋值语句改变变量，输出语句更改屏幕显示内容，例子如下： x = 1 #赋值语句 y = 2 #赋值语句 z = x + y #表达式 print(z) #输出语句 十四：获取用户输入 如何获取用户的输入，Python提供了内置函数input来简单实现此功能。例子如下： Python 3.6.3 (v3.6.3:2c5fed8, Oct 3 2017, 18:11:49) [MSC v.1900 64 bit (AMD64)] on win32 Type \"copyright\", \"credits\" or \"license()\" for more information. >>> input('please input : ') please input : 20190902 '20190902' >>> x = input('x : ') x : 12 >>> y = input('y : ') y : 34 >>> print(int(x) * int(y)) 408 >>> 十五：赋值魔法 1. 序列解包 Python可同时（并行）给多个变量赋值 >>> x,y,z = 1,2,3 >>> print(x,' ',y,' ',z) 1 2 3 使用这种方法还可以交换多个变量的值： >>> x,y = y,x >>> print(x,y,z) 2 1 3 实际上，这里的操作称为序列解包（或可迭代对象解包）：将一个序列（或任意可迭代对象）解包，并将得到的值存储到一系列变量中： >>> values = 1,2,3 >>> values (1, 2, 3) >>> x,y,z = values >>> print(x,y,z) 1 2 3 2. 链式赋值 链式赋值是一种快捷方式，用于将多个变量关联到一个值，有点像之前的并行赋值，但只涉及到一个值。 #链式赋值 >>> a=b=2 #等价方式 >>> a=2 >>> a=b #不等价方式 >>> a=2 >>> b=2 3.增强赋值 可以不编写代码x = x + 1，而将右边表达式中的运算符( + )移到赋值运算符( = )的前面，从而写成x += 1，这样在python中被称为增强赋值，适用于所有标准运算符。 >>> x = 2 >>> x += 1 >>> x *= 4 >>> x /= 2 >>> x 6.0 增强赋值同样适用于其他数据类型（只要使用的双目运算符可用于这些数据类型） >>> fnord = 'foo' >>> fnord += ' bar' >>> fnord *= 2 >>> fnord 'foo barfoo bar' 通过使用增强赋值，可让代码更紧凑，更简洁，同样在很多情况下可读性更强。 十六：运行Python脚本 1. 命令提示符运行Python脚本 在Window平台下打开DOS窗口输入如下命令可执行脚本： C:\\>python hello.py 在UNIX下通过打开shell输入如下命令可执行脚本： $ python hello.py 在linux下命令也类似 $ python3 hello.py 2. 作为普通程序运行Python 在UNIX系统中，添加如下代码在Python脚本的第一行即可轻松运行脚本： #！/usr/bin/env python 该语句从#！，后跟python的绝对路径，最后是指定对于脚本进行解释的工具。这样无论Python库在什么地方，这都可以让你能够像运行普通程序一样运行Python脚本。 要想像普通程序一样运行脚本，还必须将其变为可执行的： $ chmod a+x hello.py 现在，可以像下面这样运行它（当前目录包含在执行路径中）： $ hellp.py 如果以上命令不起作用，那么可以试试这个： $ ./hello.py 当然，您也可以对文件进行重命名并删除扩展名.py,看起来会更像普通程序 在Windows中，扩展名.py是让Python脚本像普通程序一样运行的关键所在。如果当前计算机正确安装并配置了Python环境，点击hello.py文件会触发一个DOS窗口，如果没有输入项之类的逻辑，窗口会很快一闪而过，这是因为程序结束后窗口会立即关闭，为了防止这种情况，可在代码末尾添加1如下代码阻止关闭窗口： input(\"Press \") MU_zjm®Designer, Developer & overall web enthusiastCopyright © MU_zjm all right reserved, powered by MU_zjm!created by MU_zjm 2019-08-28 12:00:00 "},"Python/Chapter2.html":{"url":"Python/Chapter2.html","title":"第二章：数据类型","keywords":"","body":"TreeviewCopyright © all right reserved, powered by aleen42 第二章：数据类型 一：python中的变量 二：多个变量赋值 三：标准数据类型 四：Number（数字） 1. 概述 2. 数值运算 3. 数值类型实例 五：String（字符串） 六：List（列表） 七：Tuple（元组） 八：Set（集合） 九：Dictionary（字典） 十：数据类型转换 第二章：数据类型 一：python中的变量 Python 中的变量不需要声明。每个变量在使用前都必须赋值，变量赋值以后该变量才会被创建。 在 Python 中，变量就是变量，它没有类型，我们所说的\"类型\"是变量所指的内存中对象的类型。 在Python中，名称（标识符）只能由字母，数字和下划线(_)组成，且不能以数字开头。 等号（=）用来给变量赋值。 等号（=）运算符左边是一个变量名,等号（=）运算符右边是存储在变量中的值。例如： #!/usr/bin/python3 counter = 100 # 整型变量 miles = 1000.0 # 浮点型变量 name = \"runoob\" # 字符串 print (counter) print (miles) print (name) 执行以上程序会输出如下结果： 100 1000.0 runoob 二：多个变量赋值 Python允许你同时为多个变量赋值。例如： a = b = c = 1 以上实例，创建一个整型对象，值为 1，从后向前赋值，三个变量被赋予相同的数值。 您也可以为多个对象指定多个变量。例如： a, b, c = 1, 2, \"runoob\" 三：标准数据类型 Python3 中有六个标准的数据类型： Number（数字） String（字符串） List（列表） Tuple（元组） Set（集合） Dictionary（字典） Python3 的六个标准数据类型中： 不可变数据（3 个）：Number（数字）、String（字符串）、Tuple（元组）； 可变数据（3 个）：List（列表）、Dictionary（字典）、Set（集合）。 四：Number（数字） 1. 概述 Python3 支持 int、float、bool、complex（复数）。 在Python 3里，只有一种整数类型 int，表示为长整型，没有 python2 中的 Long。 像大多数语言一样，数值类型的赋值和计算都是很直观的。 内置的 type() 函数可以用来查询变量所指的对象类型。 >>> a, b, c, d = 20, 5.5, True, 4+3j >>> print(type(a), type(b), type(c), type(d)) 此外还可以用 isinstance 来判断： >>>a = 111 >>> isinstance(a, int) True >>> isinstance 和 type 的区别在于： type()不会认为子类是一种父类类型。 isinstance()会认为子类是一种父类类型。 >>> class A: ... pass ... >>> class B(A): ... pass ... >>> isinstance(A(), A) True >>> type(A()) == A True >>> isinstance(B(), A) True >>> type(B()) == A False 注意：在 Python2 中是没有布尔型的，它用数字 0 表示 False，用 1 表示 True。到 Python3 中，把 True 和 False 定义成关键字了，但它们的值还是 1 和 0，它们可以和数字相加。 当你指定一个值时，Number 对象就会被创建： var1 = 1 var2 = 10 您也可以使用del语句删除一些对象引用。 del语句的语法是： del var1[,var2[,var3[....,varN]]] 您可以通过使用del语句删除单个或多个对象。例如： del var del var_a, var_b 2. 数值运算 5 + 4 # 加法 9 4.3 - 2 # 减法 2.3 3 * 7 # 乘法 21 2 / 4 # 除法，得到一个浮点数 0.5 2 // 4 # 除法，得到一个整数 0 17 % 3 # 取余 2 2 ** 5 # 乘方 32 注意： 1、Python可以同时为多个变量赋值，如a, b = 1, 2。 2、一个变量可以通过赋值指向不同类型的对象。 3、数值的除法包含两个运算符：/ 返回一个浮点数，// 返回一个整数。 4、在混合计算时，Python会把整型转换成为浮点数。 3. 数值类型实例 int float complex 10 0.0 3.14j 100 15.20 45.j -786 -21.9 9.322e-36j 080 32.3e+18 .876j -0490 -90. -.6545+0J -0x260 -32.54e100 3e+26J 0x69 70.2E-12 4.53e-7j Python还支持复数，复数由实数部分和虚数部分构成，可以用a + bj,或者complex(a,b)表示， 复数的实部a和虚部b都是浮点型。 五：String（字符串） Python中的字符串用单引号 ' 或双引号 \" 括起来，同时使用反斜杠 \\ 转义特殊字符。 字符串的截取的语法格式如下： 变量[头下标:尾下标] #!/usr/bin/python3 str = 'Runoob' print (str) # 输出字符串 print (str[0:-1]) # 输出第一个到倒数第二个的所有字符 print (str[0]) # 输出字符串第一个字符 print (str[2:5]) # 输出从第三个开始到第五个的字符 print (str[2:]) # 输出从第三个开始的后的所有字符 print (str * 2) # 输出字符串两次 print (str + \"TEST\") # 连接字符串 执行以上程序会输出如下结果： Runoob Runoo R noo noob RunoobRunoob RunoobTEST ​ Python 使用反斜杠()转义特殊字符，如果你不想让反斜杠发生转义，可以在字符串前面添加一个 r，表示原始字符串： >>> print('Ru\\noob') Ru oob >>> print(r'Ru\\noob') Ru\\noob >>> 另外，反斜杠(\\)可以作为续行符，表示下一行是上一行的延续。也可以使用 **\"\"\"...\"\"\"** 或者 **'''...'''** 跨越多行。 ​ 注意，Python 没有单独的字符类型，一个字符就是长度为1的字符串。 >>>word = 'Python' >>> print(word[0], word[5]) P n >>> print(word[-1], word[-6]) n P 与 C 字符串不同的是，Python 字符串不能被改变。向一个索引位置赋值，比如word[0] = 'm'会导致错误。 注意： 1、反斜杠可以用来转义，使用r可以让反斜杠不发生转义。 2、字符串可以用+运算符连接在一起，用*运算符重复。 3、Python中的字符串有两种索引方式，从左往右以0开始，从右往左以-1开始。 4、Python中的字符串不能改变。 六：List（列表） ​ List（列表） 是 Python 中使用最频繁的数据类型。 ​ 列表可以完成大多数集合类的数据结构实现。列表中元素的类型可以不相同，它支持数字，字符串甚至可以包含列表（所谓嵌套）。 ​ 列表是写在方括号 [] 之间、用逗号分隔开的元素列表。 ​ 和字符串一样，列表同样可以被索引和截取，列表被截取后返回一个包含所需元素的新列表。 ​ 列表截取的语法格式如下： 变量[头下标:尾下标] #!/usr/bin/python3 list = [ 'abcd', 786 , 2.23, 'runoob', 70.2 ] tinylist = [123, 'runoob'] print (list) # 输出完整列表 print (list[0]) # 输出列表第一个元素 print (list[1:3]) # 从第二个开始输出到第三个元素 print (list[2:]) # 输出从第三个元素开始的所有元素 print (tinylist * 2) # 输出两次列表 print (list + tinylist) # 连接列表 以上实例输出结果： ['abcd', 786, 2.23, 'runoob', 70.2] abcd [786, 2.23] [2.23, 'runoob', 70.2] [123, 'runoob', 123, 'runoob'] ['abcd', 786, 2.23, 'runoob', 70.2, 123, 'runoob'] 与Python字符串不一样的是，列表中的元素是可以改变的： a = [1, 2, 3, 4, 5, 6] a[0] = 9 a[2:5] = [13, 14, 15] a [9, 2, 13, 14, 15, 6] a[2:5] = [] # 将对应的元素值设置为 [] a [9, 2, 6] List 内置了有很多方法，例如 append()、pop() 等等，这在后面会讲到。 注意： 1、List写在方括号之间，元素用逗号隔开。 2、和字符串一样，list可以被索引和切片。 3、List可以使用+操作符进行拼接。 4、List中的元素是可以改变的。 Python 列表截取可以接收第三个参数，参数作用是截取的步长，以下实例在索引 1 到索引 4 的位置并设置为步长为 2（间隔一个位置）来截取字符串： 如果第三个参数为负数表示逆向读取，以下实例用于翻转字符串： def reverseWords(input): # 通过空格将字符串分隔符，把各个单词分隔为列表 inputWords = input.split(\" \") # 翻转字符串 # 假设列表 list = [1,2,3,4], # list[0]=1, list[1]=2 ，而 -1 表示最后一个元素 list[-1]=4 ( 与 list[3]=4 一样) # inputWords[-1::-1] 有三个参数 # 第一个参数 -1 表示最后一个元素 # 第二个参数为空，表示移动到列表末尾 # 第三个参数为步长，-1 表示逆向 inputWords=inputWords[-1::-1] # 重新组合字符串 output = ' '.join(inputWords) return output if __name__ == \"__main__\": input = 'I like runoob' rw = reverseWords(input) print(rw) 输出结果为： runoob like I 七：Tuple（元组） ​ 元组（tuple）与列表类似，不同之处在于元组的元素不能修改。元组写在小括号 () 里，元素之间用逗号隔开。 元组中的元素类型也可以不相同： #!/usr/bin/python3 tuple = ( 'abcd', 786 , 2.23, 'runoob', 70.2 ) tinytuple = (123, 'runoob') print (tuple) # 输出完整元组 print (tuple[0]) # 输出元组的第一个元素 print (tuple[1:3]) # 输出从第二个元素开始到第三个元素 print (tuple[2:]) # 输出从第三个元素开始的所有元素 print (tinytuple * 2) # 输出两次元组 print (tuple + tinytuple) # 连接元组 以上实例输出结果： ('abcd', 786, 2.23, 'runoob', 70.2) abcd (786, 2.23) (2.23, 'runoob', 70.2) (123, 'runoob', 123, 'runoob') ('abcd', 786, 2.23, 'runoob', 70.2, 123, 'runoob') ​ 元组与字符串类似，可以被索引且下标索引从0开始，-1 为从末尾开始的位置。也可以进行截取（看上面，这里不再赘述）。 其实，可以把字符串看作一种特殊的元组。 >>>tup = (1, 2, 3, 4, 5, 6) >>> print(tup[0]) 1 >>> print(tup[1:5]) (2, 3, 4, 5) >>> tup[0] = 11 # 修改元组元素的操作是非法的 Traceback (most recent call last): File \"\", line 1, in TypeError: 'tuple' object does not support item assignment >>> 虽然tuple的元素不可改变，但它可以包含可变的对象，比如list列表。 构造包含 0 个或 1 个元素的元组比较特殊，所以有一些额外的语法规则： tup1 = () # 空元组 tup2 = (20,) # 一个元素，需要在元素后添加逗号 string、list 和 tuple 都属于 sequence（序列）。 注意： 1、与字符串一样，元组的元素不能修改。 2、元组也可以被索引和切片，方法一样。 3、注意构造包含 0 或 1 个元素的元组的特殊语法规则。 4、元组也可以使用+操作符进行拼接。 八：Set（集合） ​ 集合（set）是由一个或数个形态各异的大小整体组成的，构成集合的事物或对象称作元素或是成员。 ​ 基本功能是进行成员关系测试和删除重复元素。 ​ 可以使用大括号 { } 或者 set() 函数创建集合，注意：创建一个空集合必须用 set() 而不是 { }，因为 { } 是用来创建一个空字典。 ​ 创建格式： parame = {value01,value02,...} 或者 set(value) #!/usr/bin/python3 student = {'Tom', 'Jim', 'Mary', 'Tom', 'Jack', 'Rose'} print(student) # 输出集合，重复的元素被自动去掉 # 成员测试 if 'Rose' in student : print('Rose 在集合中') else : print('Rose 不在集合中') # set可以进行集合运算 a = set('abracadabra') b = set('alacazam') print(a) print(a - b) # a 和 b 的差集 print(a | b) # a 和 b 的并集 print(a & b) # a 和 b 的交集 print(a ^ b) # a 和 b 中不同时存在的元素 以上实例输出结果： {'Mary', 'Jim', 'Rose', 'Jack', 'Tom'} Rose 在集合中 {'b', 'a', 'c', 'r', 'd'} {'b', 'd', 'r'} {'l', 'r', 'a', 'c', 'z', 'm', 'b', 'd'} {'a', 'c'} {'l', 'r', 'z', 'm', 'b', 'd'} 九：Dictionary（字典） ​ 字典（dictionary）是Python中另一个非常有用的内置数据类型。 ​ 列表是有序的对象集合，字典是无序的对象集合。两者之间的区别在于：字典当中的元素是通过键来存取的，而不是通过偏移存取。 ​ 字典是一种映射类型，字典用 { } 标识，它是一个无序的 键(key) : 值(value) 的集合。 ​ 键(key)必须使用不可变类型。 ​ 在同一个字典中，键(key)必须是唯一的。 #!/usr/bin/python3 dict = {} dict['one'] = \"1 - 菜鸟教程\" dict[2] = \"2 - 菜鸟工具\" tinydict = {'name': 'runoob','code':1, 'site': 'www.runoob.com'} print (dict['one']) # 输出键为 'one' 的值 print (dict[2]) # 输出键为 2 的值 print (tinydict) # 输出完整的字典 print (tinydict.keys()) # 输出所有键 print (tinydict.values()) # 输出所有值 以上实例输出结果： 1 - 菜鸟教程 2 - 菜鸟工具 {'name': 'runoob', 'code': 1, 'site': 'www.runoob.com'} dict_keys(['name', 'code', 'site']) dict_values(['runoob', 1, 'www.runoob.com']) 构造函数 dict() 可以直接从键值对序列中构建字典如下： >>>dict([('Runoob', 1), ('Google', 2), ('Taobao', 3)]) {'Taobao': 3, 'Runoob': 1, 'Google': 2} >>> {x: x**2 for x in (2, 4, 6)} {2: 4, 4: 16, 6: 36} >>> dict(Runoob=1, Google=2, Taobao=3) {'Runoob': 1, 'Google': 2, 'Taobao': 3} 另外，字典类型也有一些内置的函数，例如clear()、keys()、values()等。 注意： 1、字典是一种映射类型，它的元素是键值对。 2、字典的关键字必须为不可变类型，且不能重复。 3、创建空字典使用 { }。 十：数据类型转换 有时候，我们需要对数据内置的类型进行转换，数据类型的转换，你只需要将数据类型作为函数名即可。 以下几个内置的函数可以执行数据类型之间的转换。这些函数返回一个新的对象，表示转换的值。 函数 描述 int(x [,base]) 将x转换为一个整数 float(x) 将x转换到一个浮点数 complex(real [,imag]) 创建一个复数 str(x) 将对象 x 转换为字符串 repr(x) 将对象 x 转换为表达式字符串 eval(str) 用来计算在字符串中的有效Python表达式,并返回一个对象 tuple(s) 将序列 s 转换为一个元组 list(s) 将序列 s 转换为一个列表 set(s) 转换为可变集合 dict(d) 创建一个字典。d 必须是一个 (key, value)元组序列。 frozenset(s) 转换为不可变集合 chr(x) 将一个整数转换为一个字符 ord(x) 将一个字符转换为它的整数值 hex(x) 将一个整数转换为一个十六进制字符串 oct(x) 将一个整数转换为一个八进制字符串 MU_zjm®Designer, Developer & overall web enthusiastCopyright © MU_zjm all right reserved, powered by MU_zjm!created by MU_zjm 2019-08-28 12:00:00 "},"Python/Chapter3.html":{"url":"Python/Chapter3.html","title":"第三章：运算符","keywords":"","body":"TreeviewCopyright © all right reserved, powered by aleen42 第三章：运算符 一：什么是运算符？ 二：算术运算符 三：比较运算符 四：赋值运算符 五：位运算符 六：逻辑运算符 七：成员运算符 八：身份运算符 九：运算符优先级 第三章：运算符 一：什么是运算符？ 本章节主要说明Python的运算符。举个简单的例子 4 +5 = 9 。 例子中，4 和 5 被称为操作数，\"+\" 称为运算符。 Python语言支持以下类型的运算符: 算术运算符 比较（关系）运算符 赋值运算符 逻辑运算符 位运算符 成员运算符 身份运算符 运算符优先级 接下来让我们一个个来学习Python的运算符。 二：算术运算符 以下假设变量a为10，变量b为21： 运算符 描述 实例 + 加 - 两个对象相加 a + b 输出结果 31 - 减 - 得到负数或是一个数减去另一个数 a - b 输出结果 -11 * 乘 - 两个数相乘或是返回一个被重复若干次的字符串 a * b 输出结果 210 / 除 - x 除以 y b / a 输出结果 2.1 % 取模 - 返回除法的余数 b % a 输出结果 1 ** 幂 - 返回x的y次幂 a**b 为10的21次方 // 取整除 - 向下取接近除数的整数 >>> 9//2 4 >>> -9//2 -5 以下实例演示了Python所有算术运算符的操作： #!/usr/bin/python3 a = 21 b = 10 c = 0 c = a + b print (\"1 - c 的值为：\", c) c = a - b print (\"2 - c 的值为：\", c) c = a * b print (\"3 - c 的值为：\", c) c = a / b print (\"4 - c 的值为：\", c) c = a % b print (\"5 - c 的值为：\", c) # 修改变量 a 、b 、c a = 2 b = 3 c = a**b print (\"6 - c 的值为：\", c) a = 10 b = 5 c = a//b print (\"7 - c 的值为：\", c) 以上实例输出结果： 1 - c 的值为： 31 2 - c 的值为： 11 3 - c 的值为： 210 4 - c 的值为： 2.1 5 - c 的值为： 1 6 - c 的值为： 8 7 - c 的值为： 2 还有一些特殊例子： >>>10//-3 -4 >>>-10//3 -4 >>>-3**2 -9 此处可以看出，乘方运算符优先级高于求负运算符。当然，可以使用括号改变其优先级 三：比较运算符 以下假设变量a为10，变量b为20： 运算符 描述 实例 == 等于 - 比较对象是否相等 (a == b) 返回 False。 != 不等于 - 比较两个对象是否不相等 (a != b) 返回 True。 > 大于 - 返回x是否大于y (a > b) 返回 False。 小于 - 返回x是否小于y。所有比较运算符返回1表示真，返回0表示假。这分别与特殊的变量True和False等价。注意，这些变量名的大写。 (a >= 大于等于 - 返回x是否大于等于y。 (a >= b) 返回 False。 小于等于 - 返回x是否小于等于y。 (a 以下实例演示了Python所有比较运算符的操作： #!/usr/bin/python3 a = 21 b = 10 c = 0 if ( a == b ): print (\"1 - a 等于 b\") else: print (\"1 - a 不等于 b\") if ( a != b ): print (\"2 - a 不等于 b\") else: print (\"2 - a 等于 b\") if ( a b ): print (\"4 - a 大于 b\") else: print (\"4 - a 小于等于 b\") # 修改变量 a 和 b 的值 a = 5; b = 20; if ( a = a ): print (\"6 - b 大于等于 a\") else: print (\"6 - b 小于 a\") 以上实例输出结果： 1 - a 不等于 b 2 - a 不等于 b 3 - a 大于等于 b 4 - a 大于 b 5 - a 小于等于 b 6 - b 大于等于 a 四：赋值运算符 以下假设变量a为10，变量b为20： 运算符 描述 实例 = 简单的赋值运算符 c = a + b 将 a + b 的运算结果赋值为 c += 加法赋值运算符 c += a 等效于 c = c + a -= 减法赋值运算符 c -= a 等效于 c = c - a *= 乘法赋值运算符 c = a 等效于 c = c a /= 除法赋值运算符 c /= a 等效于 c = c / a %= 取模赋值运算符 c %= a 等效于 c = c % a **= 幂赋值运算符 c = a 等效于 c = c a //= 取整除赋值运算符 c //= a 等效于 c = c // a 以下实例演示了Python所有赋值运算符的操作： #!/usr/bin/python3 a = 21 b = 10 c = 0 c = a + b print (\"1 - c 的值为：\", c) c += a print (\"2 - c 的值为：\", c) c *= a print (\"3 - c 的值为：\", c) c /= a print (\"4 - c 的值为：\", c) c = 2 c %= a print (\"5 - c 的值为：\", c) c **= a print (\"6 - c 的值为：\", c) c //= a print (\"7 - c 的值为：\", c) 以上实例输出结果： 1 - c 的值为： 31 2 - c 的值为： 52 3 - c 的值为： 1092 4 - c 的值为： 52.0 5 - c 的值为： 2 6 - c 的值为： 2097152 7 - c 的值为： 99864 五：位运算符 按位运算符是把数字看作二进制来进行计算的。Python中的按位运算法则如下： 下表中变量 a 为 60，b 为 13二进制格式如下： a = 0011 1100 b = 0000 1101 ----------------- a&b = 0000 1100 a|b = 0011 1101 a^b = 0011 0001 ~a = 1100 0011 运算符 描述 实例 & 按位与运算符：参与运算的两个值,如果两个相应位都为1,则该位的结果为1,否则为0 (a & b) 输出结果 12 ，二进制解释： 0000 1100 注 按位或运算符：只要对应的二个二进位有一个为1时，结果位就为1。 a和b按位异或输出结果 61 ，二进制解释： 0011 1101 ^ 按位异或运算符：当两对应的二进位相异时，结果为1 (a ^ b) 输出结果 49 ，二进制解释： 0011 0001 ~ 按位取反运算符：对数据的每个二进制位取反,即把1变为0,把0变为1。~x 类似于 -x-1 (~a ) 输出结果 -61 ，二进制解释： 1100 0011， 在一个有符号二进制数的补码形式。 左移动运算符：运算数的各二进位全部左移若干位，由\" a >> 右移动运算符：把\">>\"左边的运算数的各二进位全部右移若干位，\">>\"右边的数指定移动的位数 a >> 2 输出结果 15 ，二进制解释： 0000 1111 注：上表中的注代表 | ，为避免表格转换异常，不能出现在MarkDown表格中 以下实例演示了Python所有位运算符的操作： #!/usr/bin/python3 a = 60 # 60 = 0011 1100 b = 13 # 13 = 0000 1101 c = 0 c = a & b; # 12 = 0000 1100 print (\"1 - c 的值为：\", c) c = a | b; # 61 = 0011 1101 print (\"2 - c 的值为：\", c) c = a ^ b; # 49 = 0011 0001 print (\"3 - c 的值为：\", c) c = ~a; # -61 = 1100 0011 print (\"4 - c 的值为：\", c) c = a > 2; # 15 = 0000 1111 print (\"6 - c 的值为：\", c) 以上实例输出结果： 1 - c 的值为： 12 2 - c 的值为： 61 3 - c 的值为： 49 4 - c 的值为： -61 5 - c 的值为： 240 6 - c 的值为： 15 六：逻辑运算符 Python语言支持逻辑运算符，以下假设变量 a 为 10, b为 20: 运算符 逻辑表达式 描述 实例 and x and y 布尔\"与\" - 如果 x 为 False，x and y 返回 False，否则它返回 y 的计算值。 (a and b) 返回 20。 or x or y 布尔\"或\" - 如果 x 是 True，它返回 x 的值，否则它返回 y 的计算值。 (a or b) 返回 10。 not not x 布尔\"非\" - 如果 x 为 True，返回 False 。如果 x 为 False，它返回 True。 not(a and b) 返回 False 以上实例输出结果： #!/usr/bin/python3 a = 10 b = 20 if ( a and b ): print (\"1 - 变量 a 和 b 都为 true\") else: print (\"1 - 变量 a 和 b 有一个不为 true\") if ( a or b ): print (\"2 - 变量 a 和 b 都为 true，或其中一个变量为 true\") else: print (\"2 - 变量 a 和 b 都不为 true\") # 修改变量 a 的值 a = 0 if ( a and b ): print (\"3 - 变量 a 和 b 都为 true\") else: print (\"3 - 变量 a 和 b 有一个不为 true\") if ( a or b ): print (\"4 - 变量 a 和 b 都为 true，或其中一个变量为 true\") else: print (\"4 - 变量 a 和 b 都不为 true\") if not( a and b ): print (\"5 - 变量 a 和 b 都为 false，或其中一个变量为 false\") else: print (\"5 - 变量 a 和 b 都为 true\") 以上实例输出结果： 1 - 变量 a 和 b 都为 true 2 - 变量 a 和 b 都为 true，或其中一个变量为 true 3 - 变量 a 和 b 有一个不为 true 4 - 变量 a 和 b 都为 true，或其中一个变量为 true 5 - 变量 a 和 b 都为 false，或其中一个变量为 false 七：成员运算符 ​ 除了以上的一些运算符之外，Python还支持成员运算符，测试实例中包含了一系列的成员，包括字符串，列表或元组。 运算符 描述 实例 in 如果在指定的序列中找到值返回 True，否则返回 False。 x 在 y 序列中 , 如果 x 在 y 序列中返回 True。 not in 如果在指定的序列中没有找到值返回 True，否则返回 False。 x 不在 y 序列中 , 如果 x 不在 y 序列中返回 True。 以下实例演示了Python所有成员运算符的操作： #!/usr/bin/python3 a = 10 b = 20 list = [1, 2, 3, 4, 5 ]; if ( a in list ): print (\"1 - 变量 a 在给定的列表中 list 中\") else: print (\"1 - 变量 a 不在给定的列表中 list 中\") if ( b not in list ): print (\"2 - 变量 b 不在给定的列表中 list 中\") else: print (\"2 - 变量 b 在给定的列表中 list 中\") # 修改变量 a 的值 a = 2 if ( a in list ): print (\"3 - 变量 a 在给定的列表中 list 中\") else: print (\"3 - 变量 a 不在给定的列表中 list 中\") 以上实例输出结果： 1 - 变量 a 不在给定的列表中 list 中 2 - 变量 b 不在给定的列表中 list 中 3 - 变量 a 在给定的列表中 list 中 八：身份运算符 身份运算符用于比较两个对象的存储单元 运算符 描述 实例 is is 是判断两个标识符是不是引用自一个对象 x is y, 类似 id(x) == id(y) , 如果引用的是同一个对象则返回 True，否则返回 False is not is not 是判断两个标识符是不是引用自不同对象 x is not y ， 类似 id(a) != id(b)。如果引用的不是同一个对象则返回结果 True，否则返回 False。 注： id()函数用于获取对象内存地址。 以下实例演示了Python所有身份运算符的操作： #!/usr/bin/python3 a = 20 b = 20 if ( a is b ): print (\"1 - a 和 b 有相同的标识\") else: print (\"1 - a 和 b 没有相同的标识\") if ( id(a) == id(b) ): print (\"2 - a 和 b 有相同的标识\") else: print (\"2 - a 和 b 没有相同的标识\") # 修改变量 b 的值 b = 30 if ( a is b ): print (\"3 - a 和 b 有相同的标识\") else: print (\"3 - a 和 b 没有相同的标识\") if ( a is not b ): print (\"4 - a 和 b 没有相同的标识\") else: print (\"4 - a 和 b 有相同的标识\") 以上实例输出结果： 1 - a 和 b 有相同的标识 2 - a 和 b 有相同的标识 3 - a 和 b 没有相同的标识 4 - a 和 b 没有相同的标识 is 与 == 区别： is 用于判断两个变量引用对象是否为同一个， == 用于判断引用变量的值是否相等。 a = [1, 2, 3] b = a b is a True b == a True b = a[:] b is a False b == a True 九：运算符优先级 以下表格列出了从最高到最低优先级的所有运算符： 运算符 描述 ** 指数 (最高优先级) ~ + - 按位翻转, 一元加号和减号 (最后两个的方法名为 +@ 和 -@) * / % // 乘，除，取模和取整除 + - 加法减法 >> 右移，左移运算符 & 位 'AND' ^ \\ 位运算符 >= 比较运算符 <> == != 等于运算符 = %= /= //= -= += = *= 赋值运算符 is is not 身份运算符 in not in 成员运算符 not and or 逻辑运算符 以下实例演示了Python所有运算符优先级的操作 #!/usr/bin/python3 a = 20 b = 10 c = 15 d = 5 e = 0 e = (a + b) * c / d #( 30 * 15 ) / 5 print (\"(a + b) * c / d 运算结果为：\", e) e = ((a + b) * c) / d # (30 * 15 ) / 5 print (\"((a + b) * c) / d 运算结果为：\", e) e = (a + b) * (c / d); # (30) * (15/5) print (\"(a + b) * (c / d) 运算结果为：\", e) e = a + (b * c) / d; # 20 + (150/5) print (\"a + (b * c) / d 运算结果为：\", e) 以上实例输出结果： (a + b) * c / d 运算结果为： 90.0 ((a + b) * c) / d 运算结果为： 90.0 (a + b) * (c / d) 运算结果为： 90.0 a + (b * c) / d 运算结果为： 50.0 MU_zjm®Designer, Developer & overall web enthusiastCopyright © MU_zjm all right reserved, powered by MU_zjm!created by MU_zjm 2019-08-28 12:00:00 "},"Python/Chapter4.html":{"url":"Python/Chapter4.html","title":"第四章：数字","keywords":"","body":"TreeviewCopyright © all right reserved, powered by aleen42 第四章：数字 1. 概述 2. 数字类型转换 3. 数字运算 4. 数学函数 5. 随机数函数 6. 三角函数 7. 数学常量 8.进制 第四章：数字 1. 概述 Python 数字数据类型用于存储数值。 数据类型是不允许改变的,这就意味着如果改变数字数据类型的值，将重新分配内存空间。 以下实例在变量赋值时 Number 对象将被创建： var1 = 1 var2 = 10 您也可以使用del语句删除一些数字对象的引用。 del语句的语法是： del var1[,var2[,var3[....,varN]]] 您可以通过使用del语句删除单个或多个对象的引用，例如： del var del var_a, var_b Python 支持三种不同的数值类型： 整型(Int) - 通常被称为是整型或整数，是正或负整数，不带小数点。Python3 整型是没有限制大小的，可以当作 Long 类型使用，所以 Python3 没有 Python2 的 Long 类型。 浮点型(float) - 浮点型由整数部分与小数部分组成，浮点型也可以使用科学计数法表示（2.5e2 = 2.5 x 102 = 250） 复数( (complex)) - 复数由实数部分和虚数部分构成，可以用a + bj,或者complex(a,b)表示， 复数的实部a和虚部b都是浮点型。 我们可以使用十六进制和八进制来代表整数： >>> number = 0xA0F # 十六进制 >>> number 2575 >>> number=0o37 # 八进制 >>> number 31 int float complex 10 0.0 3.14j 100 15.20 45.j -786 -21.9 9.322e-36j 080 32.3e+18 .876j -0490 -90. -.6545+0J -0x260 -32.54e100 3e+26J 0x69 70.2E-12 4.53e-7j ​ Python支持复数，复数由实数部分和虚数部分构成，可以用a + bj,或者complex(a,b)表示， 复数的实部a和虚部b都是浮点型。 2. 数字类型转换 有时候，我们需要对数据内置的类型进行转换，数据类型的转换，你只需要将数据类型作为函数名即可。 int(x) 将x转换为一个整数。 float(x) 将x转换到一个浮点数。 complex(x) 将x转换到一个复数，实数部分为 x，虚数部分为 0。 complex(x, y) 将 x 和 y 转换到一个复数，实数部分为 x，虚数部分为 y。x 和 y 是数字表达式。 以下实例将浮点数变量 a 转换为整数： >>> a = 1.0 >>> int(a) 1 3. 数字运算 Python 解释器可以作为一个简单的计算器，您可以在解释器里输入一个表达式，它将输出表达式的值。 表达式的语法很直白： +, -, * 和 /, 和其它语言（如Pascal或C）里一样。例如： >>> 2 + 2 4 >>> 50 - 5*6 20 >>> (50 - 5*6) / 4 5.0 >>> 8 / 5 # 总是返回一个浮点数 1.6 注意：在不同的机器上浮点运算的结果可能会不一样。 在整数除法中，除法 / 总是返回一个浮点数，如果只想得到整数的结果，丢弃可能的分数部分，可以使用运算符 // ： >>> 17 / 3 # 整数除法返回浮点型 5.666666666666667 >>> >>> 17 // 3 # 整数除法返回向下取整后的结果 5 >>> 17 % 3 # ％操作符返回除法的余数 2 >>> 5 * 3 + 2 17 注意：// 得到的并不一定是整数类型的数，它与分母分子的数据类型有关系。 >>> 7//2 3 >>> 7.0//2 3.0 >>> 7//2.0 3.0 >>> 等号 = 用于给变量赋值。赋值之后，除了下一个提示符，解释器不会显示任何结果。 >>> width = 20 >>> height = 5*9 >>> width * height 900 Python 可以使用 ** 操作来进行幂运算： >>> 5 ** 2 # 5 的平方 25 >>> 2 ** 7 # 2的7次方 128 变量在使用前必须先\"定义\"（即赋予变量一个值），否则会出现错误： >>> n # 尝试访问一个未定义的变量 Traceback (most recent call last): File \"\", line 1, in NameError: name 'n' is not defined 不同类型的数混合运算时会将整数转换为浮点数： >>> 3 * 3.75 / 1.5 7.5 >>> 7.0 / 2 3.5 在交互模式中，最后被输出的表达式结果被赋值给变量 _ 。例如： >>> tax = 12.5 / 100 >>> price = 100.50 >>> price * tax 12.5625 >>> price + _ 113.0625 >>> round(_, 2) 113.06 此处， _ 变量应被用户视为只读变量。 4. 数学函数 函数 返回值 ( 描述 ) abs(x) 返回数字的绝对值，如abs(-10) 返回 10 ceil(x) 返回数字的上入整数，如math.ceil(4.1) 返回 5 cmp(x, y) 如果 x y 返回 1。 Python 3 已废弃，使用 (x>y)-(x。 exp(x) 返回e的x次幂(ex),如math.exp(1) 返回2.718281828459045 fabs(x) 返回数字的绝对值，如math.fabs(-10) 返回10.0 floor(x) 返回数字的下舍整数，如math.floor(4.9)返回 4 log(x) 如math.log(math.e)返回1.0,math.log(100,10)返回2.0 log10(x) 返回以10为基数的x的对数，如math.log10(100)返回 2.0 max(x1, x2,...) 返回给定参数的最大值，参数可以为序列。 min(x1, x2,...) 返回给定参数的最小值，参数可以为序列。 modf(x) 返回x的整数部分与小数部分，两部分的数值符号与x相同，整数部分以浮点型表示。 pow(x, y) x**y 运算后的值。 round(x [,n]) 返回浮点数x的四舍五入值，如给出n值，则代表舍入到小数点后的位数。 sqrt(x) 返回数字x的平方根。 5. 随机数函数 随机数可以用于数学，游戏，安全等领域中，还经常被嵌入到算法中，用以提高算法效率，并提高程序的安全性。 Python包含以下常用随机数函数： 函数 描述 choice(seq) 从序列的元素中随机挑选一个元素，比如random.choice(range(10))，从0到9中随机挑选一个整数。 randrange ([start,] stop [,step]) 从指定范围内，按指定基数递增的集合中获取一个随机数，基数默认值为 1 random() 随机生成下一个实数，它在[0,1)范围内。 seed([x]) 改变随机数生成器的种子seed。如果你不了解其原理，你不必特别去设定seed，Python会帮你选择seed。 shuffle(lst) 将序列的所有元素随机排序 uniform(x, y) 随机生成下一个实数，它在[x,y]范围内。 6. 三角函数 Python包括以下三角函数： 函数 描述 acos(x) 返回x的反余弦弧度值。 asin(x) 返回x的反正弦弧度值。 atan(x) 返回x的反正切弧度值。 atan2(y, x) 返回给定的 X 及 Y 坐标值的反正切值。 cos(x) 返回x的弧度的余弦值。 hypot(x, y) 返回欧几里德范数 sqrt(xx + yy)。 sin(x) 返回的x弧度的正弦值。 tan(x) 返回x弧度的正切值。 degrees(x) 将弧度转换为角度,如degrees(math.pi/2) ， 返回90.0 radians(x) 将角度转换为弧度 7. 数学常量 常量 描述 pi 数学常量 pi（圆周率，一般以π来表示） e 数学常量 e，e即自然常数（自然常数）。 8.进制 Python中进制表示法均已0开头，十六进制，八进制和二进制表示如下所示： Python 3.6.3 (v3.6.3:2c5fed8, Oct 3 2017, 18:11:49) [MSC v.1900 64 bit (AMD64)] on win32 Type \"copyright\", \"credits\" or \"license()\" for more information. >>> 0xAF 175 >>> 0o10 8 >>> 0b1011010010 722 >>> MU_zjm®Designer, Developer & overall web enthusiastCopyright © MU_zjm all right reserved, powered by MU_zjm!created by MU_zjm 2019-08-28 12:00:00 "},"Python/Chapter5.html":{"url":"Python/Chapter5.html","title":"第五章：字符串","keywords":"","body":"TreeviewCopyright © all right reserved, powered by aleen42 第五章：字符串 1. 概述 2. 访问字符串中的值 3. 字符串更新 4. 转义字符和原始字符串 5. 字符串运算符 6. 字符串格式化 6.1 格式化概述 6. 2 基本转换 6.3 宽度，精度和千位分隔符 6.4 符号，对齐和用0填充 7. 长字符串 8. Unicode 字符串 9. 字符串内建函数 第五章：字符串 1. 概述 字符串是 Python 中最常用的数据类型。我们可以使用引号( ' 或 \" )来创建字符串。 创建字符串很简单，只要为变量分配一个值即可。例如： var1 = 'Hello World!' var2 = \"Runoob\" 2. 访问字符串中的值 Python 不支持单字符类型，单字符在 Python 中也是作为一个字符串使用。 Python 访问子字符串，可以使用方括号来截取字符串，如下实例： #!/usr/bin/python3 var1 = 'Hello World!' var2 = \"Runoob\" print (\"var1[0]: \", var1[0]) print (\"var2[1:5]: \", var2[1:5]) 以上实例执行结果： var1[0]: H var2[1:5]: unoo 3. 字符串更新 你可以截取字符串的一部分并与其他字段拼接，如下实例： #!/usr/bin/python3 var1 = 'Hello World!' print (\"已更新字符串 : \", var1[:6] + 'Runoob!') 以上实例执行结果 已更新字符串 : Hello Runoob! 4. 转义字符和原始字符串 在需要在字符中使用特殊字符时，python用反斜杠()转义字符。如下表： 转义字符 描述 (在行尾时) 续行符 \\ 反斜杠符号 \\' 单引号 \\\" 双引号 \\a 响铃 \\b 退格(Backspace) \\000 空 \\n 换行 \\v 纵向制表符 \\t 横向制表符 \\r 回车 \\f 换页 \\oyy 八进制数，yy 代表的字符，例如：\\o12 代表换行，其中 o 是字母，不是数字 0。 \\xyy 十六进制数，yy代表的字符，例如：\\x0a代表换行 \\other 其它的字符以普通格式输出 如果在字符串前加一个字母r即表示原始字符串，表示遇到转义符不进行转义 str = r'C:/Users' 如你所见，原始字符串用前缀r表示，看起来原始字符串包含任何字符，但仍存在例外，引号仍需要通过转义符转义，而且用于转义的转义符反斜杠因为前缀r的存在，也会显示在最终的字符串中。 >>> print(r'let\\'s go!') let\\'s go! >>> 另外，原始字符串不能以单个反斜杠结尾。换而言之，原始字符串的最后一个字符不能是反斜杠，除非你对其进行转义，（而如果进行转义，用于转义的反斜杠也会出现在最终的字符串中），为了解决此类问题，存在多种办法，但基本技巧都是将反斜杠单独作为一个字符串： >>> print(r'c;\\Users\\Public\\Desktop' '\\\\') c;\\Users\\Public\\Desktop\\ >>> 5. 字符串运算符 下表实例变量a值为字符串 \"Hello\"，b变量值为 \"Python\"： 操作符 描述 实例 + 字符串连接 a + b 输出结果： HelloPython * 重复输出字符串 a*2 输出结果：HelloHello [] 通过索引获取字符串中字符 a[1] 输出结果 e [ : ] 截取字符串中的一部分，遵循左闭右开原则，str[0,2] 是不包含第 3 个字符的。 a[1:4] 输出结果 ell in 成员运算符 - 如果字符串中包含给定的字符返回 True 'H' in a 输出结果 True not in 成员运算符 - 如果字符串中不包含给定的字符返回 True 'M' not in a 输出结果 True r/R 原始字符串 - 原始字符串：所有的字符串都是直接按照字面的意思来使用，没有转义特殊或不能打印的字符。 原始字符串除在字符串的第一个引号前加上字母 r（可以大小写）以外，与普通字符串有着几乎完全相同的语法。 print( r'\\n' ) print( R'\\n' ) % 格式字符串 请看下一节内容。 #!/usr/bin/python3 a = \"Hello\" b = \"Python\" print(\"a + b 输出结果：\", a + b) print(\"a * 2 输出结果：\", a * 2) print(\"a[1] 输出结果：\", a[1]) print(\"a[1:4] 输出结果：\", a[1:4]) if( \"H\" in a) : print(\"H 在变量 a 中\") else : print(\"H 不在变量 a 中\") if( \"M\" not in a) : print(\"M 不在变量 a 中\") else : print(\"M 在变量 a 中\") print (r'\\n') print (R'\\n') 以上实例输出结果为： a + b 输出结果： HelloPython a * 2 输出结果： HelloHello a[1] 输出结果： e a[1:4] 输出结果： ell H 在变量 a 中 M 不在变量 a 中 \\n \\n 6. 字符串格式化 6.1 格式化概述 如何设置字符串的格式？ Python 支持格式化字符串的输出 。尽管这样可能会用到非常复杂的表达式，但基本方案都是使用字符串格式设置运算符：百分号 通过转换说明符%s,指明要将值插入什么位置，其中s代表将其视为字符串进行格式设置，如果指定的值不是字符串，则可使用str将其转为字符串。 使用模板字符串，这里不做详解。 在 Python 中，字符串格式化使用与 C 中 sprintf 函数一样的语法。 #!/usr/bin/python3 print (\"我叫 %s 今年 %d 岁!\" % ('小明', 10)) 以上实例输出结果： 我叫 小明 今年 10 岁! 详细例子： Python 3.6.3 (v3.6.3:2c5fed8, Oct 3 2017, 18:11:49) [MSC v.1900 64 bit (AMD64)] on win32 Type \"copyright\", \"credits\" or \"license()\" for more information. >>> format = 'hello, %s. %s enough for ya?' >>> values = ('world','Hot') >>> format % values 'hello, world. Hot enough for ya?' >>> from string import Template #模板字符串 >>> tem1 = Template('Hello, $who! $what enough for ya?') >>> tem1.substitute(who='Mars',what='Dusty') 'Hello, Mars! Dusty enough for ya?' >>> from math import pi >>> \"{name} is approximately {value}.\".format(value=pi,name='Π') 'Π is approximately 3.141592653589793.' >>> \"{name} is approximately {value:2f}.\".format(value=pi,name='Π') 'Π is approximately 3.141593.' >>> \"{name} is approximately {value:.2f}.\".format(value=pi,name='Π') 'Π is approximately 3.14.' >>> from math import e >>> \"Euler's constant is rough {e}.\".format(e=e) \"Euler's constant is rough 2.718281828459045.\" >>> \"{foo} {} {bar} {} \".format(1,2,bar=4,foo=3) '3 1 4 2 ' >>> \"{foo} {1} {bar} {0} \".format(1,2,bar=4,foo=3) #多了一个空格 SyntaxError: unexpected indent >>> \"{foo} {1} {bar} {0} \".format(1,2,bar=4,foo=3) '3 2 4 1 ' >>> python字符串格式化符号: 符 号 描述 %c 格式化字符及其ASCII码 %s 格式化字符串 %d 格式化整数 %u 格式化无符号整型 %o 格式化无符号八进制数 %x 格式化无符号十六进制数 %X 格式化无符号十六进制数（大写） %f 格式化浮点数字，可指定小数点后的精度 %e 用科学计数法格式化浮点数 %E 作用同%e，用科学计数法格式化浮点数 %g %f和%e的简写 %G %f 和 %E 的简写 %p 用十六进制数格式化变量的地址 格式化操作符辅助指令: 符号 功能 * 定义宽度或者小数点精度 - 用做左对齐 + 在正数前面显示加号( + ) 在正数前面显示空格 # 在八进制数前面显示零('0')，在十六进制前面显示'0x'或者'0X'(取决于用的是'x'还是'X') 0 显示的数字前面填充'0'而不是默认的空格 % '%%'输出一个单一的'%' (var) 映射变量(字典参数) m.n. m 是显示的最小总宽度,n 是小数点后的位数(如果可用的话) Python2.6 开始，新增了一种格式化字符串的函数 str.format()，它增强了字符串格式化的功能。 6. 2 基本转换 在格式字符串中，重头戏之一是替换字段。替换字段如下部分组成： 字段名：索引或标识符，指出要设置哪个值的格式并使用结果来替换该字段。除指定值外，还可指定值的特定部分，如列表的元素。 转换标志：跟在叹号后边的单个字符。当前支持的字符包括r(表示repr),s(表示str)和a(表示ascii)。如果你指定了转换标志，将不使用对象本身的格式设置机制，而是使用指定的函数将对象转换为字符串，再做进一步的格式设置。 格式说明符：跟在冒号后边的表达式，详细制定最终的格式，包括格式类型（如字符串，浮点数，十六进制数等等），字段宽度，数的精度，如何显示符号和千位分隔符，以及各种对齐和填充方式等等。 在最简单的情况下，只需向format提供设置其格式的未命名参数，并在格式字符串中使用未命名字段。此时，将按照顺序将字段和参数匹配： >>> '{},{} and {}'.format(\"first\",'second','third') 'first,second and third' 可以通过索引指定要在哪个字段中使用相应的未命名参数，这样可以不按顺序使用未命名参数： >>> '{0},{2} and {1}'.format(\"first\",\"third\",\"second\") 'first,second and third' 指定要在字段中包含的值后，就可添加有关如何设置其格式的指令。首先，需要设置一个转换标志： Python 3.6.3 (v3.6.3:2c5fed8, Oct 3 2017, 18:11:49) [MSC v.1900 64 bit (AMD64)] on win32 Type \"copyright\", \"credits\" or \"license()\" for more information. >>> print(\"{pi!s} {pi!r} {pi!a} \".format(pi='π')) π 'π' '\\u03c0' # str repr ascii >>> num = 42 >>> \"the number is {num}.\".format(num=num) 'the number is 42.' #默认十进制整数 >>> \"the number is {num:f}.\".format(num=num) 'the number is 42.000000.' #浮点数 >>> \"the number is {num:b}.\".format(num=num) 'the number is 101010.' #二进制 您还可以指定要转换的值是哪种类型，更准确的说，是要将其视为那种类型。例如，你可能要提供一个整数，但要将其作为小数处理，为此可在格式说明后使用字符f表示浮点数，完整的类型说明符如下： 类型 说明 b 将整数表示为二进制数 c 将整数解读为Unicode码点 d 将整数视为十进制数进行处理，这是整数默认使用的说明符 e 使用科学表示法来表示小数（用e来表示整数） E 与e相同，用E来表示指数 f 将小数表示为定点数 F 与f相同，但对于特殊值（nan和inf）,使用大写表示 g 自动在顶点表示法和科学表示法之间做出选择。这是默认用于小数的说明符，但在默认情况下至少由一位小数 G 与g相同，但使用大写来表示指数和特殊值 n 与g相同，但插入随区域而异的数字分隔符 o 将整数表示为八进制数 s 保持字符串的格式不变，这是默认用于字符串的说明符 x 将整数表示为十六进制数并使用小写字母 X 与x相同，但使用大写字母 % 将数表示为百分比值（乘以100，按说明符设置格式，再在后边加%） 6.3 宽度，精度和千位分隔符 设置浮点数（或其他更具体的小数类型）的格式时，默认在小数点后显示6位小数，并根据要设置字段的宽度，而不进行任何形式的填充。 宽度是使用整数指定的： >>> \"the number is {num:10}.\".format(num=num) 'the number is 42.' #数字右对齐 >>> \"the name is {name:10}.\".format(name='Bob') 'the name is Bob .' #字符串左对齐 精度也是使用整数指定的，但需要在它前面加上一个表示小数点的句点. >>> from math import pi #pi常量需导入 >>> 'Pi value is {pi:.7f}.'.format(pi=pi) 'Pi value is 3.1415927.' >>> 实际上，对于其他类型也可以指定精度，一般不常见： >>> '{:.7}'.format(\"I love python!\") 'I love ' >>> 最后，可以使用逗号来指出你要添加的千位分隔符： >>> 'One googol is {:,}.'.format(10**100) 'One googol is 10,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000.' >>> 6.4 符号，对齐和用0填充 有很多用于设置字符格式的机制，比如便于打印整齐的表格。在大多数情况下，只需指定宽度和精度。但是如果包含负数，原本漂亮的输出就没那么完美了。而且字符串和数字默认的对齐方式不同，如果同时包含字符串和数时，怎么应对这种不同的默认对齐方式。这里介绍一下填充。在指定宽度和精度的数前面，可添加一个标志。这个标志可以是零，加号，减号，空格，其中零即使用0来填充数字： >>> '{:010.2f}'.format(pi) '0000003.14' 要指定对齐方式，可使用左尖括号（）右对齐： >>> print('{0:10.2f}'.format(pi)) 3.14 3.14 3.14 可以使用填充字符来扩充对齐说明符，可使用指定的字符串而不是默认的空格填充： >>> '{:$^15}'.format(\" WIN BIG \") '$$$ WIN BIG $$$' 还有更具体的说明符＝，可指定填充字符放在符号和数字之间： >>> print('{0:10.2f}\\n{1:10.2f}'.format(pi,-pi)) 3.14 -3.14 >>> print('{0:10.2f}\\n{1:=10.2f}'.format(pi,-pi)) 3.14 - 3.14 如果要给正数加上符号，可在对齐说明符后添加说明符+。如果将符号说明符指定为空格，会在证书前面加上空格而不是+： >>> print('{0:-.2}\\n{1:-.2}'.format(pi,-pi)) 3.1 -3.1 >>> print('{0:+.2}\\n{1:+.2}'.format(pi,-pi)) +3.1 -3.1 >>> print('{0: .2}\\n{1: .2}'.format(pi,-pi)) 3.1 -3.1 最后一个要介绍的是井号（#），它可以被放置在说明符和宽度之间(如果存在这两个设置)，该选项会触发另一种转换方式，转换细节随类型而异： >>> '{:b}'.format(42) '101010' >>> '{:#b}'.format(42) '0b101010' >>> '{:g}'.format(42) '42' >>> '{:#g}'.format(42) '42.0000' 7. 长字符串 python三引号允许一个字符串跨多行，字符串中可以包含换行符、制表符以及其他特殊字符。实例如下 #!/usr/bin/python3 para_str = \"\"\"这是一个多行字符串的实例 多行字符串可以使用制表符 TAB ( \\t )。 也可以使用换行符 [ \\n ]。 \"\"\" print (para_str) 以上实例执行结果为： 这是一个多行字符串的实例 多行字符串可以使用制表符 TAB ( )。 也可以使用换行符 [ ]。 ​ 三引号让程序员从引号和特殊字符串的泥潭里面解脱出来，自始至终保持一小块字符串的格式是所谓的WYSIWYG（所见即所得）格式的。 一个典型的用例是，当你需要一块HTML或者SQL时，这时用字符串组合，特殊字符串转义将会非常的繁琐。 errHTML = ''' Friends CGI Demo ERROR %s ''' cursor.execute(''' CREATE TABLE users ( login VARCHAR(8), uid INTEGER, prid INTEGER) ''') Tips:常规字符串也可横跨多行。不过需要在行尾加上反斜杠，反斜杠和换行符会被转义，即忽略，例子如下： #正常的打印 print('hello,\\ word!') #合法表达式 >>> 1+2+\\ 3+4 10 #合法语句 >>> print\\ ('hello,world!') hello,world! >>> 8. Unicode 字符串 ​ 在Python2中，普通字符串是以8位ASCII码进行存储的，而Unicode字符串则存储为16位unicode字符串，这样能够表示更多的字符集。使用的语法是在字符串前面加上前缀 u。 ​ 在Python3中，所有的字符串都是Unicode字符串。 9. 字符串内建函数 Python 的字符串常用内建函数如下： 序号 方法 描述 1 capitalize() 将字符串的第一个字符转换为大写。 2 center(width, fillchar) 返回一个指定的宽度 width 居中的字符串，fillchar 为填充的字符，默认为空格。 3 count(str, beg= 0,end=len(string)) 返回 str 在 string 里面出现的次数，如果 beg 或者 end 指定则返回指定范围内 str 出现的次数。 4 bytes.decode(encoding=\"utf-8\", errors=\"strict\") Python3 中没有 decode 方法，但我们可以使用 bytes 对象的 decode() 方法来解码给定的 bytes 对象，这个 bytes 对象可以由 str.encode() 来编码返回。 5 encode(encoding='UTF-8',errors='strict') 以 encoding 指定的编码格式编码字符串，如果出错默认报一个ValueError 的异常，除非 errors 指定的是'ignore'或者'replace'。 6 endswith(suffix, beg=0, end=len(string)) 检查字符串是否以 obj 结束，如果beg 或者 end 指定则检查指定的范围内是否以 obj 结束，如果是，返回 True,否则返回 False。 7 expandtabs(tabsize=8) 把字符串 string 中的 tab 符号转为空格，tab 符号默认的空格数是 8 。 8 find(str, beg=0, end=len(string)) 检测 str 是否包含在字符串中，如果指定范围 beg 和 end ，则检查是否包含在指定范围内，如果包含返回开始的索引值，否则返回-1。 9 index(str, beg=0, end=len(string)) 跟find()方法一样，只不过如果str不在字符串中会报一个异常。 10 isalnum() 如果字符串至少有一个字符并且所有字符都是字母或数字则返 回 True,否则返回 False。 11 isalpha() 如果字符串至少有一个字符并且所有字符都是字母则返回 True, 否则返回 False。 12 isdigit() 如果字符串只包含数字则返回 True 否则返回 False。 13 islower() 如果字符串中包含至少一个区分大小写的字符，并且所有这些(区分大小写的)字符都是小写，则返回 True，否则返回 False。 14 isnumeric() 如果字符串中只包含数字字符，则返回 True，否则返回 False 15 isspace() 如果字符串中只包含空白，则返回 True，否则返回 False。 16 istitle() 如果字符串是标题化的(见 title())则返回 True，否则返回 False。 17 isupper() 如果字符串中包含至少一个区分大小写的字符，并且所有这些(区分大小写的)字符都是大写，则返回 True，否则返回 False。 18 join(seq) 以指定字符串作为分隔符，将 seq 中所有的元素(的字符串表示)合并为一个新的字符串。 19 len(string) 返回字符串长度 20 ljust(width[, fillchar]) 返回一个原字符串左对齐,并使用 fillchar 填充至长度 width 的新字符串，fillchar 默认为空格。 21 lower() 转换字符串中所有大写字符为小写. 22 lstrip() 截掉字符串左边的空格或指定字符。 23 maketrans() 创建字符映射的转换表，对于接受两个参数的最简单的调用方式，第一个参数是字符串，表示需要转换的字符，第二个参数也是字符串表示转换的目标。 24 max(str) 返回字符串 str 中最大的字母。 25 min(str) 返回字符串 str 中最小的字母。 26 replace(old, new [, max]) 把 将字符串中的 str1 替换成 str2,如果 max 指定，则替换不超过 max 次。 27 rfind(str, beg=0,end=len(string)) 类似于 find()函数，不过是从右边开始查找。 28 rindex( str, beg=0, end=len(string)) 类似于 index()，不过是从右边开始。 29 rjust(width,[, fillchar]) 返回一个原字符串右对齐,并使用fillchar(默认空格）填充至长度 width 的新字符串。 30 [rstrip() 删除字符串字符串末尾的空格。 31 split(str=\"\", num=string.count(str)) num=string.count(str)) 以 str 为分隔符截取字符串，如果 num 有指定值，则仅截取 num+1 个子字符串。 32 splitlines([keepends]) 按照行('\\r', '\\r\\n', \\n')分隔，返回一个包含各行作为元素的列表，如果参数 keepends 为 False，不包含换行符，如果为 True，则保留换行符。 33 startswith(substr, beg=0,end=len(string)) 检查字符串是否是以指定子字符串 substr 开头，是则返回 True，否则返回 False。如果beg 和 end 指定值，则在指定范围内检查。 34 strip([chars]) 在字符串上执行 lstrip()和 rstrip()。 35 swapcase() 将字符串中大写转换为小写，小写转换为大写 返回\"标题化\"的字符串,就是说所有单词都是以大写开始，其余字母均为小写(见 istitle())。 36 title() 根据 str 给出的表(包含 256 个字符)转换 string 的字符, 要过滤掉的字符放到 deletechars 参数中。 37 translate(table, deletechars=\"\") 38 upper() 转换字符串中的小写字母为大写 39 zfill (width) 返回长度为 width 的字符串，原字符串右对齐，前面填充0 40 isdecimal() 检查字符串是否只包含十进制字符，如果是返回 true，否则返回 false。 MU_zjm®Designer, Developer & overall web enthusiastCopyright © MU_zjm all right reserved, powered by MU_zjm!created by MU_zjm 2019-08-28 12:00:00 "},"Python/Chapter6.html":{"url":"Python/Chapter6.html","title":"第六章：列表","keywords":"","body":"TreeviewCopyright © all right reserved, powered by aleen42 第六章：列表 1. 概述 2. 访问列表中的值 3. 更新列表 4. 删除列表元素 5. 列表脚本操作符 6. 列表截取与拼接 7. 嵌套列表 8. 加法&乘法 9. 列表函数&方法 第六章：列表 1. 概述 序列是Python中最基本的数据结构。序列中的每个元素都分配一个数字 - 它的位置，或索引，第一个索引是0，第二个索引是1，依此类推。 Python有6个序列的内置类型，但最常见的是列表和元组。 序列都可以进行的操作包括索引，切片，加，乘，检查成员。 此外，Python已经内置确定序列的长度以及确定最大和最小的元素的方法。 列表是最常用的Python数据类型，它可以作为一个方括号内的逗号分隔值出现。 列表的数据项不需要具有相同的类型 创建一个列表，只要把逗号分隔的不同的数据项使用方括号括起来即可。如下所示： list1 = ['Google', 'Runoob', 1997, 2000]; list2 = [1, 2, 3, 4, 5 ]; list3 = [\"a\", \"b\", \"c\", \"d\"]; 与字符串的索引一样，列表索引从0开始。列表可以进行截取、组合等。 2. 访问列表中的值 使用下标索引来访问列表中的值，同样你也可以使用方括号的形式截取字符，如下所示： #!/usr/bin/python3 list1 = ['Google', 'Runoob', 1997, 2000]; list2 = [1, 2, 3, 4, 5, 6, 7 ]; print (\"list1[0]: \", list1[0]) print (\"list2[1:5]: \", list2[1:5]) 以上实例输出结果： list1[0]: Google list2[1:5]: [2, 3, 4, 5] 3. 更新列表 你可以对列表的数据项进行修改或更新，你也可以使用append()方法来添加列表项，如下所示： #!/usr/bin/python3 list = ['Google', 'Runoob', 1997, 2000] print (\"第三个元素为 : \", list[2]) list[2] = 2001 print (\"更新后的第三个元素为 : \", list[2]) 注意：我们会在接下来的章节讨论append()方法的使用 以上实例输出结果： 第三个元素为 : 1997 更新后的第三个元素为 : 2001 4. 删除列表元素 可以使用 del 语句来删除列表的的元素，如下实例： #!/usr/bin/python3 list = ['Google', 'Runoob', 1997, 2000] print (\"原始列表 : \", list) del list[2] print (\"删除第三个元素 : \", list) 以上实例输出结果： 原始列表 : ['Google', 'Runoob', 1997, 2000] 删除第三个元素 : ['Google', 'Runoob', 2000] 注意：我们会在接下来的章节讨论 remove() 方法的使用 5. 列表脚本操作符 列表对 + 和 的操作符与字符串相似。+ 号用于组合列表， 号用于重复列表。 如下所示： Python 表达式 结果 描述 len([1, 2, 3]) 3 长度 [1, 2, 3] + [4, 5, 6] [1, 2, 3, 4, 5, 6] 组合 ['Hi!'] * 4 ['Hi!', 'Hi!', 'Hi!', 'Hi!'] 重复 3 in [1, 2, 3] True 元素是否存在于列表中 for x in [1, 2, 3]: print(x, end=\" \") 1 2 3 迭代 6. 列表截取与拼接 Python的列表截取与字符串操作类型，如下所示： L=['Google', 'Runoob', 'Taobao'] 操作： Python 表达式 结果 描述 L[2] 'Taobao' 读取第三个元素 L[-2] 'Runoob' 从右侧开始读取倒数第二个元素: count from the right L[1:] ['Runoob', 'Taobao'] 输出从第二个元素开始后的所有元素 >>L=['Google', 'Runoob', 'Taobao'] >>L[2] 'Taobao' >>L[-2] 'Runoob' >>L[1:] ['Runoob', 'Taobao'] 列表还支持拼接操作： >>squares = [1, 4, 9, 16, 25] >>squares += [36, 49, 64, 81, 100] >>squares [1, 4, 9, 16, 25, 36, 49, 64, 81, 100] 详细的例子： >>> numbers = [1,2,3,4,5,6,7,8,9,10] >>> numbers[3:6] [4, 5, 6] >>> numbers[0:1] [1] >>> numbers[7:10] #这里的索引10指的是第十一个元素，虽然不曾存在第十一个元素，但已读到此位置 [8, 9, 10] >>> numbers[-3:-1] [8, 9] >>> numbers[-3:0] #起止点无交叉（起点索引大于终点索引），得到的切片为空 [] >>> numbers[-3:] [8, 9, 10] >>> numbers[:3] [1, 2, 3] >>> numbers[:] [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] >>> 切片获取域名 url = input('Please input a URL: ') domain = url[11:-4] print('url , domain is ' + domain) 运行结果如下： Please input a URL: http://www.baidu.com url , domain is baidu >>> 关于步长，进行切片时，一般都会显式或隐式的指定起点和终点，还有另一个参数：步长，而一般其默认为1，这意味着从一个元素移动到下一个元素，具体例子如下： Python 3.6.3 (v3.6.3:2c5fed8, Oct 3 2017, 18:11:49) [MSC v.1900 64 bit (AMD64)] on win32 Type \"copyright\", \"credits\" or \"license()\" for more information. >>> numbers = [1,2,3,4,5,6,7,8,9,10] >>> numbers[0:10:2] [1, 3, 5, 7, 9] >>> numbers[::3] [1, 4, 7, 10] >>> numbers[0:10:-1] [] >>> numbers[0:9:-1] [] >>> numbers[10:0:-1] [10, 9, 8, 7, 6, 5, 4, 3, 2] >>> numbers[::-2] [10, 8, 6, 4, 2] >>> numbers[5::-2] [6, 4, 2] >>> numbers[:5:-2] [10, 8] >>> 7. 嵌套列表 使用嵌套列表即在列表里创建其它列表，例如： >>a = ['a', 'b', 'c'] >>n = [1, 2, 3] >>x = [a, n] x [['a', 'b', 'c'], [1, 2, 3]] >>x[0] ['a', 'b', 'c'] >>x[0][1] 'b' 8. 加法&乘法 相同类型的序列可以使用加法拼接： Python 3.6.3 (v3.6.3:2c5fed8, Oct 3 2017, 18:11:49) [MSC v.1900 64 bit (AMD64)] on win32 Type \"copyright\", \"credits\" or \"license()\" for more information. >>> a = [1,2,3] >>> b = [4,5,6] >>> a + b [1, 2, 3, 4, 5, 6] >>> c = 'hello' >>> a + c Traceback (most recent call last): File \"\", line 1, in a + c TypeError: can only concatenate list (not \"str\") to list >>> 将序列和数X相乘，将重复这个序列x次来创建一个新的序列： Python 3.6.3 (v3.6.3:2c5fed8, Oct 3 2017, 18:11:49) [MSC v.1900 64 bit (AMD64)] on win32 Type \"copyright\", \"credits\" or \"license()\" for more information. >>> 'python ' * 5 'python python python python python ' >>> [10] * 5 [10, 10, 10, 10, 10] >>> sequence = [None] * 10 #空列表初始化 >>> sequence [None, None, None, None, None, None, None, None, None, None] >>> 9. 列表函数&方法 Python包含以下函数: 序号 函数 1 len(list) 列表元素个数 2 max(list) 返回列表元素最大值 3 min(list) 返回列表元素最小值 4 list(seq) 将元组转换为列表 Python包含以下方法: 序号 方法 1 list.append(obj) 在列表末尾添加新的对象 2 list.count(obj) 统计某个元素在列表中出现的次数 3 list.extend(seq) 在列表末尾一次性追加另一个序列中的多个值（用新列表扩展原来的列表） 4 list.index(obj) 从列表中找出某个值第一个匹配项的索引位置 5 list.insert(index, obj) 将对象插入列表 6 list.pop([index=-1]) 移除列表中的一个元素（默认最后一个元素），并且返回该元素的值 7 list.remove(obj) 移除列表中某个值的第一个匹配项 8 list.reverse() 反向列表中元素 9 list.sort( key=None, reverse=False) 对原列表进行排序 10 list.clear() 清空列表 11 list.copy() 复制列表 MU_zjm®Designer, Developer & overall web enthusiastCopyright © MU_zjm all right reserved, powered by MU_zjm!created by MU_zjm 2019-08-28 12:00:00 "},"Python/Chapter7.html":{"url":"Python/Chapter7.html","title":"第七章：元组","keywords":"","body":"TreeviewCopyright © all right reserved, powered by aleen42 第七章：元组 1.概述 2. 访问元组 3. 修改元组 4. 删除元组 5. 元组运算符 6. 元组索引，截取 7. 元组内置函数 第七章：元组 1.概述 Python 的元组与列表类似，不同之处在于元组的元素不能修改。 元组使用小括号，列表使用方括号。 元组创建很简单，只需要在括号中添加元素，并使用逗号隔开即可。 >>>tup1 = ('Google', 'Runoob', 1997, 2000); >>> tup2 = (1, 2, 3, 4, 5 ); >>> tup3 = \"a\", \"b\", \"c\", \"d\"; # 不需要括号也可以 >>> type(tup3) 创建空元组 tup1 = (); 元组中只包含一个元素时，需要在元素后面添加逗号，否则括号会被当作运算符使用： >>>tup1 = (50) >>> type(tup1) # 不加逗号，类型为整型 >>> tup1 = (50,) >>> type(tup1) # 加上逗号，类型为元组 元组与字符串类似，下标索引从0开始，可以进行截取，组合等。 2. 访问元组 元组可以使用下标索引来访问元组中的值，如下实例: #!/usr/bin/python3 tup1 = ('Google', 'Runoob', 1997, 2000) tup2 = (1, 2, 3, 4, 5, 6, 7 ) print (\"tup1[0]: \", tup1[0]) print (\"tup2[1:5]: \", tup2[1:5]) 以上实例输出结果： tup1[0]: Google tup2[1:5]: (2, 3, 4, 5) 3. 修改元组 元组中的元素值是不允许修改的，但我们可以对元组进行连接组合，如下实例: #!/usr/bin/python3 tup1 = (12, 34.56); tup2 = ('abc', 'xyz') # 以下修改元组元素操作是非法的。 # tup1[0] = 100 # 创建一个新的元组 tup3 = tup1 + tup2; print (tup3) 以上实例输出结果： (12, 34.56, 'abc', 'xyz') 4. 删除元组 元组中的元素值是不允许删除的，但我们可以使用del语句来删除整个元组，如下实例: #!/usr/bin/python3 tup = ('Google', 'Runoob', 1997, 2000) print (tup) del tup; print (\"删除后的元组 tup : \") print (tup) 以上实例元组被删除后，输出变量会有异常信息，输出如下所示： 删除后的元组 tup : Traceback (most recent call last): File \"test.py\", line 8, in print (tup) NameError: name 'tup' is not defined 5. 元组运算符 与字符串一样，元组之间可以使用 + 号和 * 号进行运算。这就意味着他们可以组合和复制，运算后会生成一个新的元组。 Python 表达式 结果 描述 len((1, 2, 3)) 3 计算元素个数 (1, 2, 3) + (4, 5, 6) (1, 2, 3, 4, 5, 6) 连接 ('Hi!',) * 4 ('Hi!', 'Hi!', 'Hi!', 'Hi!') 复制 3 in (1, 2, 3) True 元素是否存在 for x in (1, 2, 3): print (x,) 1 2 3 迭代 6. 元组索引，截取 因为元组也是一个序列，所以我们可以访问元组中的指定位置的元素，也可以截取索引中的一段元素，如下所示： 元组： L = ('Google', 'Taobao', 'Runoob') Python 表达式 结果 描述 L[2] 'Runoob' 读取第三个元素 L[-2] 'Taobao' 反向读取；读取倒数第二个元素 L[1:] ('Taobao', 'Runoob') 截取元素，从第二个开始后的所有元素。 运行实例如下： >>> L = ('Google', 'Taobao', 'Runoob') >>> L[2] 'Runoob' >>> L[-2] 'Taobao' >>> L[1:] ('Taobao', 'Runoob') 7. 元组内置函数 Python元组包含了以下内置函数 序号 方法 描述 1 len(tuple) 计算元组元素个数。 2 max(tuple) 返回元组中元素最大值。 3 min(tuple) 返回元组中元素最小值。 4 tuple(seq) 将列表转换为元组。 MU_zjm®Designer, Developer & overall web enthusiastCopyright © MU_zjm all right reserved, powered by MU_zjm!created by MU_zjm 2019-08-28 12:00:00 "},"Python/Chapter8.html":{"url":"Python/Chapter8.html","title":"第八章：字典","keywords":"","body":"TreeviewCopyright © all right reserved, powered by aleen42 第八章：字典 1. 概述 2. 访问字典里的值 3. 修改字典 4. 删除字典元素 5. 字典键的特性 6. 字典内置函数&方法 7. 字典常用方法 7.1 clear 7.2 copy 7.3 fromkeys 7.4 get 7.5 items 7.6 keys 7.7 pop 7.8 popitem 7.9 setdefault 7.10 update 7.11 values 第八章：字典 1. 概述 字典是另一种可变容器模型，且可存储任意类型对象，是一种可通过名称来访问其中各个值的数据结构，又被称为映射，字典是Python中唯一的内置映射类型，其中的值不按顺序排列，而是存储在键下。 字典由键和其对应值组成，一个键值对（K-V对）可称为项。字典的每个键值(key=>value)对用冒号(:)分割，每个对之间用逗号(,)分割，整个字典包括在花括号({})中 ,格式如下所示： d = {key1 : value1, key2 : value2 } 键必须是唯一的，但值则不必。 值可以取任何数据类型，但键必须是不可变的，如字符串，数字或元组。 一个简单的字典实例： dict = {'Alice': '2341', 'Beth': '9102', 'Cecil': '3258'} 也可如此创建字典： dict1 = { 'abc': 456 } dict2 = { 'abc': 123, 98.6: 37 } 2. 访问字典里的值 把相应的键放入到方括号中，如下实例: #!/usr/bin/python3 dict = {'Name': 'Runoob', 'Age': 7, 'Class': 'First'} print (\"dict['Name']: \", dict['Name']) print (\"dict['Age']: \", dict['Age']) 以上实例输出结果： dict['Name']: Runoob dict['Age']: 7 如果用字典里没有的键访问数据，会输出错误如下： #!/usr/bin/python3 dict = {'Name': 'Runoob', 'Age': 7, 'Class': 'First'} print (\"dict['Alice']: \", dict['Alice']) 以上实例输出结果： Traceback (most recent call last): File \"test.py\", line 5, in print (\"dict['Alice']: \", dict['Alice']) KeyError: 'Alice' 3. 修改字典 向字典添加新内容的方法是增加新的键/值对，修改或删除已有键/值对如下实例: #!/usr/bin/python3 dict = {'Name': 'Runoob', 'Age': 7, 'Class': 'First'} dict['Age'] = 8 # 更新 Age dict['School'] = \"菜鸟教程\" # 添加信息 print (\"dict['Age']: \", dict['Age']) print (\"dict['School']: \", dict['School']) 以上实例输出结果： dict['Age']: 8 dict['School']: 菜鸟教程 4. 删除字典元素 能删单一的元素也能清空字典，清空只需一项操作。 显示删除一个字典用del命令，如下实例： #!/usr/bin/python3 dict = {'Name': 'Runoob', 'Age': 7, 'Class': 'First'} del dict['Name'] # 删除键 'Name' dict.clear() # 清空字典 del dict # 删除字典 print (\"dict['Age']: \", dict['Age']) print (\"dict['School']: \", dict['School']) 但这会引发一个异常，因为用执行 del 操作后字典不再存在： Traceback (most recent call last): File \"test.py\", line 9, in print (\"dict['Age']: \", dict['Age']) TypeError: 'type' object is not subscriptable 注：del() 方法后面也会讨论。 5. 字典键的特性 字典值可以是任何的 python 对象，既可以是标准的对象，也可以是用户定义的，但键不行。 两个重要的点需要记住： 1）不允许同一个键出现两次。创建时如果同一个键被赋值两次，后一个值会被记住，如下实例： #!/usr/bin/python3 dict = {'Name': 'Runoob', 'Age': 7, 'Name': '小菜鸟'} print (\"dict['Name']: \", dict['Name']) 以上实例输出结果： dict['Name']: 小菜鸟 2）键必须不可变，所以可以用数字，字符串或元组充当，而用列表就不行，如下实例： #!/usr/bin/python3 dict = {['Name']: 'Runoob', 'Age': 7} print (\"dict['Name']: \", dict['Name']) 以上实例输出结果： Traceback (most recent call last): File \"test.py\", line 3, in dict = {['Name']: 'Runoob', 'Age': 7} TypeError: unhashable type: 'list' 6. 字典内置函数&方法 Python字典包含了以下内置函数： 序号 函数 描述 1 len(dict) 计算字典元素个数，即键的总数。 2 str(dict) 输出字典，以可打印的字符串表示。 3 type(variable) 返回输入的变量类型，如果变量是字典就返回字典类型。 Python字典包含了以下内置方法： 序号 函数 描述 1 radiansdict.clear() 删除字典内所有元素 2 radiansdict.copy() 返回一个字典的浅复制 3 radiansdict.fromkeys() 创建一个新字典，以序列seq中元素做字典的键，val为字典所有键对应的初始值 4 radiansdict.get(key, default=None) 返回指定键的值，如果值不在字典中返回default值 5 key in dict 如果键在字典dict里返回true，否则返回false 6 radiansdict.items() 以列表返回可遍历的(键, 值) 元组数组 7 radiansdict.keys() 返回一个迭代器，可以使用 list() 来转换为列表 8 radiansdict.setdefault(key, default=None) 和get()类似, 但如果键不存在于字典中，将会添加键并将值设为default 9 radiansdict.update(dict2) 把字典dict2的键/值对更新到dict里 10 radiansdict.values() 返回一个迭代器，可以使用 list() 来转换为列表 11 pop(key[,default]) 删除字典给定键 key 所对应的值，返回值为被删除的值。key值必须给出。 否则，返回default值。 12 popitem() 随机返回并删除字典中的一对键和值(一般删除末尾对)。 7. 字典常用方法 7.1 clear 删除所有字典项，此操作就地执行，因此无返回值(或者说返回None) Python 3.6.3 (v3.6.3:2c5fed8, Oct 3 2017, 18:11:49) [MSC v.1900 64 bit (AMD64)] on win32 Type \"copyright\", \"credits\" or \"license()\" for more information. >>> d = {} >>> d['name'] = 'Gumby' >>> d['age'] = 42 >>> d {'name': 'Gumby', 'age': 42} >>> f = d #浅拷贝 >>> f {'name': 'Gumby', 'age': 42} >>> f = {} #第一种清空，不影响原字典 >>> f {} >>> d {'name': 'Gumby', 'age': 42} >>> returned_value = d.clear() #第二种清空，原字典被操作 >>> d {} 7.2 copy 返回一个新字典，其中包含的键值对和原来字典完全相同（该方法执行的是浅复制，即值本身还是原件，而非副本），当替换副本中的值时，原件不受影响。 >>> x = {'username':'admin','machines':['foo','bar','baz']} >>> y = x.copy() >>> y {'username': 'admin', 'machines': ['foo', 'bar', 'baz']} >>> y['username'] = 'mxl' >>> y['machines'].remove('baz') >>> y {'username': 'mxl', 'machines': ['foo', 'bar']} 然而，当修改副本中的值时（仅修改值而非替换），原件也会发生变化，因为原件指向的也是被修改的值，为解决此类问题，可使用深复制，即copy模块中的函数deepcopy >>> from copy import deepcopy >>> a = {'username':'admin','machines':['foo','bar','baz']} >>> b = a.copy() >>> c = deepcopy(a) >>> b {'username': 'admin', 'machines': ['foo', 'bar', 'baz']} >>> c {'username': 'admin', 'machines': ['foo', 'bar', 'baz']} >>> a['machines'].remove('baz') >>> b {'username': 'admin', 'machines': ['foo', 'bar']} >>> c {'username': 'admin', 'machines': ['foo', 'bar', 'baz']} 7.3 fromkeys 创建一个新字典，其中包含指定的键，且每个键对应的值都是None： >>> {}.fromkeys(['name','age']) {'name': None, 'age': None} 以上实例是首先创建了一个空字典，再对其调用fromkeys方法创建另一个字典，这是不符合Python精神的，可换成如下方式调用该方法（dict是所有字典所属的类型）： >>> dict.fromkeys(['name','age']) {'name': None, 'age': None} 如果不想使用默认值None，可自定特定值： >>> dict.fromkeys(['name','age'],'(unknown)') {'name': '(unknown)', 'age': '(unknown)'} 7.4 get 用于访问字典中指定的项，即时该项在指定地点中不存在，也不会报错，而是返回None,，当然，你也可以指定特定返回值，而如果字典包含该项，则get方法和普通字典查找相同。 >>> d = {} >>> print(d['name']) Traceback (most recent call last): File \"\", line 1, in print(d['name']) KeyError: 'name' >>> print(d.get('name')) None >>> print(d.get('name','N/A')) N/A >>> d['name'] = 'Bob' >>> d.get('name') 'Bob' 7.5 items 返回一个包含所有字典项的列表，其中每个元素都为（key,value）的形式，字典项在列表中的排列顺序不确定,返回值属于一种字典视图的特殊类型，可用于迭代，还可以确认其长度以及成员资格检查。 >>> x = {'username':'admin','machines':['foo','bar','baz']} >>> it = x.items() >>> it dict_items([('username', 'admin'), ('machines', ['foo', 'bar', 'baz'])]) >>> len(it) 2 >>> ('username','admin') in it True 视图的一个优点是不复制，其始终指向底层字典的反应，即便你修改了底层字典： >>> x = {'username':'admin','machines':['foo','bar','baz']} >>> it = x.items() >>> ('username','root') in it False >>> x['username'] = 'root' >>> ('username','root') in it True 7.6 keys 返回一个字典视图，其中包含指定字典的键。 7.7 pop 可用于获取与指定键相关联的值，并将该键值对从字典中删除 >>> d = {'a':1,'b':'2'} >>> d.pop(b) Traceback (most recent call last): File \"\", line 1, in d.pop(b) TypeError: unhashable type: 'dict' >>> d.pop('b') '2' >>> d {'a': 1} 7.8 popitem 类似于list.pop,但list.pop弹出列表中最后一个元素，而popitem是随机弹出一个字典项。如果你要以高效的方式逐个删除并处理所有字典项，可使用该方法而不需要先获取键列表。 7.9 setdefault 有点像get，因为它也获取与指定键相关联的值，而当字典中不包含该项时，会在字典中添加指定的键值对，如果存在该键值对，则返回该键值对。 >>> d = {} >>> d.setdefault('name','N/A') 'N/A' >>> d {'name': 'N/A'} >>> d.setdefault('name','???') 'N/A' 7.10 update 使用一个字典的项来更新另一个字典 >>> a = {'a':1,'b':2} >>> b= {'b':3} >>> a {'a': 1, 'b': 2} >>> b {'b': 3} >>> a.update(b) >>> a {'a': 1, 'b': 3} 7.11 values 返回一个字典中值组成的字典视图，不同于keys,此方法可能会返回重复值，因为键在字典中是唯一的，而值不是。 MU_zjm®Designer, Developer & overall web enthusiastCopyright © MU_zjm all right reserved, powered by MU_zjm!created by MU_zjm 2019-08-28 12:00:00 "},"Python/Chapter9.html":{"url":"Python/Chapter9.html","title":"第九章：集合","keywords":"","body":"TreeviewCopyright © all right reserved, powered by aleen42 第九章：集合 1. 概述 ... 2. 基本操作 2.1 添加元素 2.2 移除元素 2.3 脚本模式 2.4 计算集合元素个数 2.5 清空集合 2.6 判断元素是否在集合中存在 3. 集合内置方法完整列表 第九章：集合 1. 概述 集合（set）是一个无序的不重复元素序列。 可以使用大括号 { } 或者 set() 函数创建集合，注意：创建一个空集合必须用 set() 而不是 { }，因为 { } 是用来创建一个空字典。 创建格式： parame = {value01,value02,...} 或者 set(value) 例子： >>>basket = {'apple', 'orange', 'apple', 'pear', 'orange', 'banana'} >>>print(basket) # 这里演示的是去重功能 {'orange', 'banana', 'pear', 'apple'} >>>'orange' in basket # 快速判断元素是否在集合内 True >>>'crabgrass' in basket False 下面展示两个集合间的运算. # ... a = set('abracadabra') b = set('alacazam') a {'a', 'r', 'b', 'c', 'd'} a - b # 集合a中包含而集合b中不包含的元素 {'r', 'd', 'b'} a | b # 集合a或b中包含的所有元素 {'a', 'c', 'r', 'd', 'b', 'm', 'z', 'l'} a & b # 集合a和b中都包含了的元素 {'a', 'c'} a ^ b # 不同时包含于a和b的元素 {'r', 'd', 'b', 'm', 'z', 'l'} 类似列表推导式，同样集合支持集合推导式(Set comprehension): >>>a = {x for x in 'abracadabra' if x not in 'abc'} >>> a {'r', 'd'} 2. 基本操作 2.1 添加元素 语法格式如下： s.add( x ) 将元素 x 添加到集合 s 中，如果元素已存在，则不进行任何操作。 >>>thisset = set((\"Google\", \"Runoob\", \"Taobao\")) >>> thisset.add(\"Facebook\") >>> print(thisset) {'Taobao', 'Facebook', 'Google', 'Runoob'} 还有一个方法，也可以添加元素，且参数可以是列表，元组，字典等，语法格式如下： s.update( x ) x 可以有多个，用逗号分开。 >>>thisset = set((\"Google\", \"Runoob\", \"Taobao\")) >>>thisset.update({1,3}) >>>print(thisset) {1, 3, 'Google', 'Taobao', 'Runoob'} >>>thisset.update([1,4],[5,6]) >>>print(thisset) {1, 3, 4, 5, 6, 'Google', 'Taobao', 'Runoob'} 2.2 移除元素 语法格式如下： s.remove( x ) 将元素 x 从集合 s 中移除，如果元素不存在，则会发生错误。 >>>thisset = set((\"Google\", \"Runoob\", \"Taobao\")) >>>thisset.remove(\"Taobao\") >>>print(thisset) {'Google', 'Runoob'} >>>thisset.remove(\"Facebook\") # 不存在会发生错误 Traceback (most recent call last): File \"\", line 1, in KeyError: 'Facebook' 此外还有一个方法也是移除集合中的元素，且如果元素不存在，不会发生错误。格式如下所示： s.discard( x ) >>>thisset = set((\"Google\", \"Runoob\", \"Taobao\")) >>> thisset.discard(\"Facebook\") # 不存在不会发生错误 >>> print(thisset) {'Taobao', 'Google', 'Runoob'} 我们也可以设置随机删除集合中的一个元素，语法格式如下： s.pop() 2.3 脚本模式 thisset = set((\"Google\", \"Runoob\", \"Taobao\", \"Facebook\")) x = thisset.pop() print(x) 输出结果： $ python3 test.py Runoob 多次执行测试结果都不一样。 然而在交互模式，pop 是删除集合的第一个元素（排序后的集合的第一个元素）。 >>>thisset = set((\"Google\", \"Runoob\", \"Taobao\", \"Facebook\")) >>> thisset.pop() 'Facebook' >>> print(thisset) {'Google', 'Taobao', 'Runoob'} >>> 2.4 计算集合元素个数 语法格式如下： len(s) 计算集合 s 元素个数。 >>>thisset = set((\"Google\", \"Runoob\", \"Taobao\")) >>> len(thisset) 3 2.5 清空集合 语法格式如下： s.clear() 清空集合 s。 >>>thisset = set((\"Google\", \"Runoob\", \"Taobao\")) >>> thisset.clear() >>> print(thisset) set() 2.6 判断元素是否在集合中存在 语法格式如下： x in s 判断元素 x 是否在集合 s 中，存在返回 True，不存在返回 False。 >>>thisset = set((\"Google\", \"Runoob\", \"Taobao\")) >>> \"Runoob\" in thisset True >>> \"Facebook\" in thisset False >>> 3. 集合内置方法完整列表 方法 描述 add() 为集合添加元素 clear() 移除集合中的所有元素 copy() 拷贝一个集合 difference() 返回多个集合的差集 difference_update() 移除集合中的元素，该元素在指定的集合也存在。 discard() 删除集合中指定的元素 intersection() 返回集合的交集 intersection_update() 返回集合的交集。 isdisjoint() 判断两个集合是否包含相同的元素，如果没有返回 True，否则返回 False。 issubset() 判断指定集合是否为该方法参数集合的子集。 issuperset() 判断该方法的参数集合是否为指定集合的子集 pop() 随机移除元素 remove() 移除指定元素 symmetric_difference() 返回两个集合中不重复的元素集合。 symmetric_difference_update() 移除当前集合中在另外一个指定集合相同的元素，并将另外一个指定集合中不同的元素插入到当前集合中。 union() 返回两个集合的并集 update() 给集合添加元素 MU_zjm®Designer, Developer & overall web enthusiastCopyright © MU_zjm all right reserved, powered by MU_zjm!created by MU_zjm 2019-08-28 12:00:00 "},"Python/Chapter10.html":{"url":"Python/Chapter10.html","title":"第十章：条件控制","keywords":"","body":"TreeviewCopyright © all right reserved, powered by aleen42 第十章：条件控制 1. if 语句 2. if 嵌套 3. 更复杂的条件 3.1 比较运算符 3.1.1 相等运算符 3.1.2 相同运算符 3.1.3 成员资格运算符 3.1.4 字符串和序列比较 3.2 布尔运算符 4. 断言 第十章：条件控制 到目前为止，你所编写的程序都是逐条顺序执行的，现在需要更进一步，让程序根据不同条件选择执行特定的语句块，这正是布尔值的用武之地。 Python 条件语句是通过一条或多条语句的执行结果（True 或者 False）来决定执行的代码块。 用作布尔表达式时，下面所有的值都会被解释器视为False: False None 0 \"\" () [] {} 换而言之，标准值False和None,各种类型（包括浮点数，复数等）的数值为0，空序列（如空字符串，空元组，空列表）以及空映射（如空字典）都被视为False，而其他各种值包括标准值True，都被视为True。这意味着任何Python的值都可以被解释为真值。在有些语言中，标准真值为0（False）和1（True）。实际上，True和False不过是0和1的别名，知识表现形式不同： >>> True True >>> False False >>> True == 1 True >>> False == 1 False >>> False == 0 True >>> True + False + 42 43 1. if 语句 Python中if语句的一般形式如下所示： if condition_1: statement_block_1 elif condition_2: statement_block_2 else: statement_block_3 如果 \"condition_1\" 为 True 将执行 \"statement_block_1\" 块语句 如果 \"condition_1\" 为False，将判断 \"condition_2\" 如果\"condition_2\" 为 True 将执行 \"statement_block_2\" 块语句 如果 \"condition_2\" 为False，将执行\"statement_block_3\"块语句 Python 中用 elif 代替了 else if，所以if语句的关键字为：if – elif – else。 注意： 1、每个条件后面要使用冒号 :，表示接下来是满足条件后要执行的语句块。 2、使用缩进来划分语句块，相同缩进数的语句在一起组成一个语句块。 3、在Python中没有switch – case语句。 Gif 演示： 以下是一个简单的 if 实例： name = input(\"What's your name? \") if(name.endswith('Gumby')): print('Hello,Mr.Gumby!') 这就是if语句，让你能够有条件的执行代码。以下实例演示了狗的年龄计算判断： #!/usr/bin/python3 age = int(input(\"请输入你家狗狗的年龄: \")) print(\"\") if age 2: human = 22 + (age -2)*5 print(\"对应人类年龄: \", human) ### 退出提示 input(\"点击 enter 键退出\") 将以上脚本保存在dog.py文件中，并执行该脚本： $ python3 dog.py 请输入你家狗狗的年龄: 1 相当于 14 岁的人。 点击 enter 键退出 high_low.py文件演示了数字的比较运算： #!/usr/bin/python3 # 该实例演示了数字猜谜游戏 number = 7 guess = -1 print(\"数字猜谜游戏!\") while guess != number: guess = int(input(\"请输入你猜的数字：\")) if guess == number: print(\"恭喜，你猜对了！\") elif guess number: print(\"猜的数字大了...\") 执行以上脚本，实例输出结果如下： $ python3 high_low.py 数字猜谜游戏! 请输入你猜的数字：1 猜的数字小了... 请输入你猜的数字：9 猜的数字大了... 请输入你猜的数字：7 恭喜，你猜对了！ 2. if 嵌套 在嵌套 if 语句中，可以把 if...elif...else 结构放在另外一个 if...elif...else 结构中。 if 表达式1: 语句 if 表达式2: 语句 elif 表达式3: 语句 else: 语句 elif 表达式4: 语句 else: 语句 实例： # !/usr/bin/python3 num=int(input(\"输入一个数字：\")) if num%2==0: if num%3==0: print (\"你输入的数字可以整除 2 和 3\") else: print (\"你输入的数字可以整除 2，但不能整除 3\") else: if num%3==0: print (\"你输入的数字可以整除 3，但不能整除 2\") else: print (\"你输入的数字不能整除 2 和 3\") 将以上程序保存到 test_if.py 文件中，执行后输出结果为： $ python3 test.py 输入一个数字：6 你输入的数字可以整除 2 和 3 3. 更复杂的条件 以上时关于if的内容，接下来讲一下条件本身 3.1 比较运算符 在条件表达式中，最基本的运算符可能时比较运算符，主要用于比较： 表达式 描述 x == y x等于y x x小于y x > y x大于y x >= y x大于等于y x x小于等于y x != y x不等于y x is y x和y是同一个对象 x is not y x和y是不同的对象 x in y x是容器（如序列）y的成员 x not in y x不是容器（如序列）y的成员 与赋值一样，Python也支持链式比较：可同时使用多个比较运算符，如0 有些比较运算符需要特别注意，下面来详细介绍： 3.1.1 相等运算符 要确认两个对象是否相等，可使用比较运算符，用两个等号（==）来表示，对于初学编程语言的人而言，一定要分清单个等号和双等号的区别： 单个等号：一般表示赋值运算符，无返回值 两个等号：一般表示相等运算符，返回布尔值 3.1.2 相同运算符 这个运算符很有趣，其作用看似和==相同，但事实并非如此： >>> x = y = [1,2,3] >>> z = [1,2,3] >>> x == y True >>> x == z True >>> x is y True >>> x is z False 如果还没看明白，可以看如下实例： >>> x = [1,2,3] >>> y = [2,4] >>> x is not y True >>> del x[2] >>> y[1] = 1 >>> y.reverse >>> y.reverse() >>> x == y True >>> x is y False >>> x [1, 2] >>> y [1, 2] 总之，==是用于检查两个对象是否相等，而is是用来检查两个对象是否相同（即同一个对象）。这里需要注意的是，不要将is用于数和字符串等不可变的基本值，这样做在Python中可能导致不可预测的结果: >>> x = 1 >>> y = 1 >>> x is y True >>> z = 2 >>> x is y True >>> a = '11' >>> b = '11' >>> a is b True >>> c = '22' >>> a is b True 3.1.3 成员资格运算符 成员资格运算符in,也可以像其他运算符一样，用于条件表达式中。 3.1.4 字符串和序列比较 字符串是根据字符的字母排序顺序进行比较的。 >>> 'Alice' 虽然基于的是字母排列顺序，但字母都是Unicode字符，它们都是按照码点排列的。而实际上，字符是根据顺序值排列的。要熟悉顺序值，可使用函数ord，这个函数的作用与函数char相反 >>> 'a' >> ord('a') 97 >>> ord('b') 98 3.2 布尔运算符 至此，你已经见过很多返回真值的表达式，但你可能需要检查多个条件。假设你要编写一个程序，实现读取一个数并判断是否在1-10之间： num = input('Please input a number:') if(num = 1): print(\"Great!\") else: print(\"Wrong!\") else: print('wrong!') 以上方法虽然可行，但有点笨拙，因为出现了重复代码，重复劳动并不是一件好事，以下为一个优化方案： num = input('Please input number:') if(num = 1): print('Great!') else: print(\"Wrong!\") 布尔运算符有个有趣的特征：只做必要的运算。例如，仅当x和y都为真，表达式x and y才为真，而当x为假时，该表达式会直接返回假，而不会关心y的真假。这种行为又被称为短路逻辑（或延迟求值），布尔运算符又常被称为逻辑运算符。 4. 断言 if语句有个很有用的'亲戚'，其工作原理类似于下面的伪代码： if not condition: crash program 编写类似的代码，是因为程序在错误条件出现时立即崩溃胜过以后再崩溃。基本上，你可能要求某些条件满足(如核实函数参数满足要求或为初始测试和调试提供帮助)，为此可在语句中使用关键字assert >>> age = 10 >>> assert 0 >> age = 0 >>> assert 0 \", line 1, in assert 0 如果知道必须满足某个特定条件，程序才能正确的运行，可在程序中添加assert语句充当检查点，还可以在条件后添加一个字符串，对断言做出说明（注意逗号分隔）： >>> age = -1 >>> assert 0 \", line 1, in assert 0 MU_zjm®Designer, Developer & overall web enthusiastCopyright © MU_zjm all right reserved, powered by MU_zjm!created by MU_zjm 2019-08-28 12:00:00 "},"Python/Chapter11.html":{"url":"Python/Chapter11.html","title":"第十一章：循环语句","keywords":"","body":"TreeviewCopyright © all right reserved, powered by aleen42 第十一章：循环语句 1. while 循环 2. 无限循环 3. while 中使用 else 语句 4. 简单语句组 5. for 语句 6. range()函数 7. 跳出循环 8. 迭代 8.1 迭代字典 8.2 迭代工具 8.2.1 并行迭代 8.2.2 迭代时获取索引 8.2.3 反向迭代和排序后迭代 9. 三人行 9.1 什么都不做 9.2 使用del删除 9.3 使用exec和eval执行字符串及计算其结果 9.3.1 exec 9.3.2 eval 第十一章：循环语句 本章节将为大家介绍Python循环语句的使用。 Python中的循环语句有 for 和 while。 1. while 循环 Python中while语句的一般形式： while 判断条件： 语句 执行 Gif 演示： 同样需要注意冒号和缩进。另外，在 Python 中没有 do..while 循环。 以下实例使用了 while 来计算 1 到 100 的总和： #!/usr/bin/env python3 n = 100 sum = 0 counter = 1 while counter 执行结果如下： 1 到 100 之和为: 5050 2. 无限循环 我们可以通过设置条件表达式永远不为 false 来实现无限循环，实例如下： #!/usr/bin/python3 var = 1 while var == 1 : # 表达式永远为 true num = int(input(\"输入一个数字 :\")) print (\"你输入的数字是: \", num) print (\"Good bye!\") 执行以上脚本，输出结果如下： 输入一个数字 :5 你输入的数字是: 5 输入一个数字 : 你可以使用 CTRL+C 来退出当前的无限循环。 无限循环在服务器上客户端的实时请求非常有用。 3. while 中使用 else 语句 在 while … else 在条件语句为 false 时执行 else 的语句块： #!/usr/bin/python3 count = 0 while count 执行以上脚本，输出结果如下： 0 小于 5 1 小于 5 2 小于 5 3 小于 5 4 小于 5 5 大于或等于 5 4. 简单语句组 类似if语句的语法，如果你的while循环体中只有一条语句，你可以将该语句与while写在同一行中， 如下所示： #!/usr/bin/python flag = 1 while (flag): print ('欢迎访问菜鸟教程!') print (\"Good bye!\") 注意：以上的无限循环你可以使用 CTRL+C 来中断循环。 执行以上脚本，输出结果如下(注意可能造成计算机卡死)： 欢迎访问菜鸟教程! 欢迎访问菜鸟教程! 欢迎访问菜鸟教程! 欢迎访问菜鸟教程! 欢迎访问菜鸟教程! …… 5. for 语句 Python for循环可以遍历任何序列的项目，如一个列表或者一个字符串。 for循环的一般格式如下： for in : else: Python loop循环实例： >>>languages = [\"C\", \"C++\", \"Perl\", \"Python\"] >>> for x in languages: print (x) C C++ Perl Python >>> 以下 for 实例中使用了 break 语句，break 语句用于跳出当前循环体： #!/usr/bin/python3 sites = [\"Baidu\", \"Google\",\"Runoob\",\"Taobao\"] for site in sites: if site == \"Runoob\": print(\"菜鸟教程!\") break print(\"循环数据 \" + site) else: print(\"没有循环数据!\") print(\"完成循环!\") 执行脚本后，在循环到 \"Runoob\"时会跳出循环体： 循环数据 Baidu 循环数据 Google 菜鸟教程! 完成循环! 6. range()函数 ​ 基本上，可迭代对象是可使用for循环进行遍历的对象。而基于迭代（也就是遍历）特定范围内的数是一种常见任务，python提供有一个创建范围的内置函数range。 如果你需要遍历数字序列，可以使用内置range()函数。它会生成数列，例如: >>>for i in range(5): print(i) 0 1 2 3 4 你也可以使用range指定区间的值： >>>for i in range(5,9) : print(i) 5 6 7 8 >>> 也可以使range以指定数字开始并指定不同的增量(甚至可以是负数，有时这也叫做'步长'): >>>for i in range(0, 10, 3) : print(i) 0 3 6 9 >>> 负数： >>>for i in range(-10, -100, -30) : print(i) -10 -40 -70 >>> 您可以结合range()和len()函数以遍历一个序列的索引,如下所示: >>>a = ['Google', 'Baidu', 'Runoob', 'Taobao', 'QQ'] >>> for i in range(len(a)): print(i, a[i]) 0 Google 1 Baidu 2 Runoob 3 Taobao 4 QQ >>> 还可以使用range()函数来创建一个列表： >>>list(range(5)) [0, 1, 2, 3, 4] >>> 7. 跳出循环 ​ break 语句可以跳出 for 和 while 的循环体。如果你从 for 或 while 循环中终止，任何对应的循环 else 块将不执行。 实例如下： #!/usr/bin/python3 for letter in 'Runoob': # 第一个实例 if letter == 'b': break print ('当前字母为 :', letter) var = 10 # 第二个实例 while var > 0: print ('当期变量值为 :', var) var = var -1 if var == 5: break print (\"Good bye!\") 执行以上脚本输出结果为： 当前字母为 : R 当前字母为 : u 当前字母为 : n 当前字母为 : o 当前字母为 : o 当期变量值为 : 10 当期变量值为 : 9 当期变量值为 : 8 当期变量值为 : 7 当期变量值为 : 6 Good bye! continue语句被用来告诉Python跳过当前循环块中的剩余语句，然后继续进行下一轮循环。 #!/usr/bin/python3 for letter in 'Runoob': # 第一个实例 if letter == 'o': # 字母为 o 时跳过输出 continue print ('当前字母 :', letter) var = 10 # 第二个实例 while var > 0: var = var -1 if var == 5: # 变量为 5 时跳过输出 continue print ('当前变量值 :', var) print (\"Good bye!\") 执行以上脚本输出结果为： 当前字母 : R 当前字母 : u 当前字母 : n 当前字母 : b 当前变量值 : 9 当前变量值 : 8 当前变量值 : 7 当前变量值 : 6 当前变量值 : 4 当前变量值 : 3 当前变量值 : 2 当前变量值 : 1 当前变量值 : 0 Good bye! ​ 循环语句可以有 else 子句，它在穷尽列表(以for循环)或条件变为 false (以while循环)导致循环终止时被执行,但循环被break终止时不执行。 如下实例用于查询质数的循环例子: #!/usr/bin/python3 for n in range(2, 10): for x in range(2, n): if n % x == 0: print(n, '等于', x, '*', n//x) break else: # 循环中没有找到元素 print(n, ' 是质数') 执行以上脚本输出结果为： 2 是质数 3 是质数 4 等于 2 * 2 5 是质数 6 等于 2 * 3 7 是质数 8 等于 2 * 4 9 等于 3 * 3 8. 迭代 8.1 迭代字典 要遍历字典的所有关键字，可像遍历序列那样使用普通的for语句。 >>> d = {'x':1,'y':2,'z':3} >>> for key in d: print(key,' corresponds to ',d[key]) x corresponds to 1 y corresponds to 2 z corresponds to 3 ​ 也可以使用keys等字典方法来获取所有的键。如果只对值感兴趣，可使用d.values。你可能还记得，d.items以元组的形式返回键值对。for循环的优点之一，是可在其中使用序列解包。 8.2 迭代工具 Python提供了很多可帮助迭代序列（或其他可迭代对象）的函数，这里仅作简单介绍： 8.2.1 并行迭代 有时候，你可能想同时迭代两个序列。假设有两个列表如下： name = ['anne','beth','george','damon'] ages = [12,45,32,102] 如何打印对应的名称和年龄，目前能做到的方法如下所示： >>> for i in range(len(name)): print(i, name[i], 'is', ages[i], 'years old.') 0 anne is 12 years old. 1 beth is 45 years old. 2 george is 32 years old. 3 damon is 102 years old. ​ 其中i是用于循环索引的变量的标准名称。Python里有一个很有意思的并行迭代工具是内置函数zip，可以将两个序列“缝合”起来，并返回一个由元组组成的序列。返回值是一个适合迭代的对象，如果要查看其内容，可使用list将其转换为列表： >>> list(zip(name,ages)) [('anne', 12), ('beth', 45), ('george', 32), ('damon', 102)] 而缝合之后，可在循环中将元组解包： >>> for name,age in zip(name,ages): print(name, 'is', age, 'years old!') anne is 12 years old! beth is 45 years old! george is 32 years old! damon is 102 years old! ​ 函数zip可以用于“缝合”任意数量的序列。需要注意的是，当序列的长度不一致时，函数会将最短的序列用完后停止“缝合”，即木桶效应。 8.2.2 迭代时获取索引 ​ 有些情况下，你可能需要在迭代对象序列时同时获取当前对象的索引。例如，你可能想替换一个字符串列表里所有包含字串\"XXX\"的字符串： for string in strings: if('XXX' in string): index = strings.index(string) #在字符串列表中查找字符串 strings[index] = '[censored]' ​ 这种方法是可行的，但替换前的搜索好像没有必要。而且，如果没有替换，则搜索返回的索引可能不对，即返回的是该字符串首次出现处的索引，以下有更好的解决办法： index = 0 for string in strings: if('xxx' in string): strings[index] = '[censored]' index += 1 这种解决方案虽然可以接受，但看起来也有点笨拙，还有一种解决方案是使用内置函数enumerate： for index,string in enumerate(strings): if('xxx' in string): strings[index] = '[censored]' 这个函数让你能够迭代索引-值对，其中索引是自动提供的。 8.2.3 反向迭代和排序后迭代 这里介绍另外两个很有用的函数：reversed和sorted。它们类似于列表方法reverse和sort，但是可用于任何序列和可迭代的对象，且不立刻修改对象，而是返回反转和排序后的版本。 >>> sorted([4,3,6,8,3]) [3, 3, 4, 6, 8] >>> sorted('Hello,World!') ['!', ',', 'H', 'W', 'd', 'e', 'l', 'l', 'l', 'o', 'o', 'r'] >>> list(reversed('Hello,World!')) ['!', 'd', 'l', 'r', 'o', 'W', ',', 'o', 'l', 'l', 'e', 'H'] >>> '@'.join(reversed('Hello,World!')) '!@d@l@r@o@W@,@o@l@l@e@H' >>> '_'.join(reversed('Hello,World!')) '!_d_l_r_o_W_,_o_l_l_e_H' ​ 请注意，sorted返回一个列表，而reversed则像zip那样返回一个更神秘的可迭代对象。你无需关心这意味着什么，只管在for循环或join等方法中使用它。而不会有任何问题。只是你不能对它进行索引或切片操作，也不能对它调用列表的方法。如果想要执行这些方法，则需要先使用list对返回的对象进行转换。 要按照字母排序，可先转换为小写。为此，可将sort或sorted的key参数设置为str.lower。例如： >>> sorted('aBc',key = str.lower) ['a', 'B', 'c'] >>> sorted('aBc') ['B', 'a', 'c'] 9. 三人行 这里大致讲一下另外三条语句：pass，del和exec。 9.1 什么都不做 Python pass是空语句，是为了保持程序结构的完整性（Python中代码块不能为空）。 pass 不做任何事情，一般用做占位语句，如下实例 >>>while True: pass # 等待键盘中断 (Ctrl+C) 最小的类: >>>class MyEmptyClass: pass 以下实例在字母为 o 时 执行 pass 语句块: #!/usr/bin/python3 for letter in 'Runoob': if letter == 'o': pass print ('执行 pass 块') print ('当前字母 :', letter) print (\"Good bye!\") 执行以上脚本输出结果为： 当前字母 : R 当前字母 : u 当前字母 : n 执行 pass 块 当前字母 : o 执行 pass 块 当前字母 : o 当前字母 : b Good bye! 9.2 使用del删除 对于你不再使用的对象，Python通常会将其删除（因为没有任何变量和1数据结构成员指向它）。 >>> scoundrel = {'age':42,'first name':'Robin','last name':'of Locksley'} >>> robin = scoundrel >>> scoundrel {'age': 42, 'first name': 'Robin', 'last name': 'of Locksley'} >>> robin {'age': 42, 'first name': 'Robin', 'last name': 'of Locksley'} >>> scoundrel = None >>> scoundrel >>> robin {'age': 42, 'first name': 'Robin', 'last name': 'of Locksley'} ​ 最初，两个变量指向同一个字典，因此将None赋值给其中一个变量，依然可以通过另一个变量访问这个字典。但是如果将另一个变量也置为None，则该字典就漂浮在计算机内存中，没有任何名称与之相关联，也再也无法获取或使用它。因此，python会直接将其删除，这又被称为垃圾收集。 ​ 另一种办法使用del语句，这样不仅会删除该对象的引用，还会删除名称本身。这样看似简单，但有时还是难以理解，例如当两个名称指向同一个列表时，使用del删除其中一个却并不会影响另一个，你仅仅时删除了一个访问该列表的名称而已。而实际上，在Python中，根本没有办法删除值，而且你也不需要这么做，因为对于你而言，你不再使用的值，Python解释器会自动将其删除（立刻）。 9.3 使用exec和eval执行字符串及计算其结果 有时候，你可能想动态的编写Python代码，并将其作为语句进行执行或作为表达式进行计算。 9.3.1 exec 函数exec将字符串作为代码执行 >>> exec('print(\"Hello,World!\")') Hello,World! ​ 然而，调用函数时只给它提供一个参数绝非好事。在大多数情况下，还应向它传递一个命名空间--用于放置变量的的地方，否则代码将可能污染你的命名空间，即修改你的变量。例如，你在代码中使用了名称sqrt，会出现什么样的结果： >>> from math import sqrt >>> sqrt(4) 2.0 >>> exec('sqrt = 1') >>> sqrt(4) Traceback (most recent call last): File \"\", line 1, in sqrt(4) TypeError: 'int' object is not callable ​ 既然如此，为什么还要将字符串作为代码执行呢？函数exec主要用于动态地创建代码字符串。如果这些字符串来自其他地方（比如说用户），就几乎无法确认它将包含什么内容。因此为了安全起见，需要提供一个字典充当命名空间。为此，你添加第二个参数--字典，用作代码字符串的命名空间。 Python 3.6.3 (v3.6.3:2c5fed8, Oct 3 2017, 18:11:49) [MSC v.1900 64 bit (AMD64)] on win32 Type \"copyright\", \"credits\" or \"license()\" for more information. >>> from math import sqrt >>> scope = {} >>> exec('sqrt = 1', scope) >>> sqrt(4) 2.0 >>> scope['sqrt'] 1 ​ 如你所见，可能带来破坏的代码并非覆盖函数sqrt。函数sqrt该怎样还怎样，而通过exec执行赋值语句创建的变量位于scope中。 ​ 请注意，如果你尝试将scope打印出来，将发现它包含很多内容，这是因为自动在其中添加了包含所有内置函数和值的字典 _buildins _ 9.3.2 eval ​ eval是一个类似于exec的内置函数。exec执行一系列Python语句。而eval计算用字符串表示的python表达式的值，并返回结果（exec什么都不返回，因为它本身就是条语句）。例如，你可以使用如下代码创建一个Python计算器： >>> eval(input('Enter an arithmetic expression:')) Enter an arithmetic expression:6 + 18 * 2 42 与exec一样，eval可以提供一个命名空间，虽然表达式通常不会像语句那样给变量重新赋值 MU_zjm®Designer, Developer & overall web enthusiastCopyright © MU_zjm all right reserved, powered by MU_zjm!created by MU_zjm 2019-08-28 12:00:00 "},"Python/Chapter12.html":{"url":"Python/Chapter12.html","title":"第十二章：迭代器和生成器","keywords":"","body":"TreeviewCopyright © all right reserved, powered by aleen42 第十二章：迭代器和生成器 1. 迭代器 2. 创建一个迭代器 3. 生成器 第十二章：迭代器和生成器 1. 迭代器 迭代是Python最强大的功能之一，是访问集合元素的一种方式。 迭代器是一个可以记住遍历的位置的对象。 迭代器对象从集合的第一个元素开始访问，直到所有的元素被访问完结束。迭代器只能往前不会后退。 迭代器有两个基本的方法：iter() 和 next()。 字符串，列表或元组对象都可用于创建迭代器： >>> list=[1,2,3,4] >>> it = iter(list) # 创建迭代器对象 >>> print (next(it)) # 输出迭代器的下一个元素 1 >>> print (next(it)) 2 >>> 迭代器对象可以使用常规for语句进行遍历： #!/usr/bin/python3 list=[1,2,3,4] it = iter(list) # 创建迭代器对象 for x in it: print (x, end=\" \") 执行以上程序，输出结果如下： 1 2 3 4 也可以使用 next() 函数： #!/usr/bin/python3 import sys # 引入 sys 模块 list=[1,2,3,4] it = iter(list) # 创建迭代器对象 while True: try: print (next(it)) except StopIteration: sys.exit() 执行以上程序，输出结果如下： 1 2 3 4 2. 创建一个迭代器 把一个类作为一个迭代器使用需要在类中实现两个方法 iter() 与 next() 。 如果你已经了解的面向对象编程，就知道类都有一个构造函数，Python 的构造函数为 init(), 它会在对象初始化的时候执行。 iter() 方法返回一个特殊的迭代器对象， 这个迭代器对象实现了 next() 方法并通过 StopIteration 异常标识迭代的完成。 next() 方法（Python 2 里是 next()）会返回下一个迭代器对象。 创建一个返回数字的迭代器，初始值为 1，逐步递增 1： class MyNumbers: def __iter__(self): self.a = 1 return self def __next__(self): x = self.a self.a += 1 return x myclass = MyNumbers() myiter = iter(myclass) print(next(myiter)) print(next(myiter)) print(next(myiter)) print(next(myiter)) print(next(myiter)) 执行输出结果为： 1 2 3 4 5 StopIteration 异常用于标识迭代的完成，防止出现无限循环的情况，在 next() 方法中我们可以设置在完成指定循环次数后触发 StopIteration 异常来结束迭代。 在 20 次迭代后停止执行： class MyNumbers: def __iter__(self): self.a = 1 return self def __next__(self): if self.a 执行输出结果为： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 3. 生成器 在 Python 中，使用了 yield 的函数被称为生成器（generator）。 跟普通函数不同的是，生成器是一个返回迭代器的函数，只能用于迭代操作，更简单点理解生成器就是一个迭代器。 在调用生成器运行的过程中，每次遇到 yield 时函数会暂停并保存当前所有的运行信息，返回 yield 的值, 并在下一次执行 next() 方法时从当前位置继续运行。 调用一个生成器函数，返回的是一个迭代器对象。 以下实例使用 yield 实现斐波那契数列： #!/usr/bin/python3 import sys def fibonacci(n): # 生成器函数 - 斐波那契 a, b, counter = 0, 1, 0 while True: if (counter > n): return yield a a, b = b, a + b counter += 1 f = fibonacci(10) # f 是一个迭代器，由生成器返回生成 while True: try: print (next(f), end=\" \") except StopIteration: sys.exit() 执行以上程序，输出结果如下： 0 1 1 2 3 5 8 13 21 34 55 MU_zjm®Designer, Developer & overall web enthusiastCopyright © MU_zjm all right reserved, powered by MU_zjm!created by MU_zjm 2019-08-28 12:00:00 "},"Python/Chapter13.html":{"url":"Python/Chapter13.html","title":"第十三章：抽象和函数","keywords":"","body":"TreeviewCopyright © all right reserved, powered by aleen42 第十三章：抽象和函数 1. 懒惰是一种美德 2. 自定义函数 3. 函数调用 3. 参数传递 3.1 可更改(mutable)与不可更改(immutable)对象 3.1.1 不可变对象实例 3.1.2 可变对象实例 4. 参数 4.1 必需参数 4.2 关键字参数 4.3 默认参数 4.4 不定长参数 5. 匿名函数 6. return语句 7.作用域 8. 变量作用域 7.1 全局变量和局部变量 7.2 global 和 nonlocal关键字 9. 递归 9.1 阶乘和幂 9.2 二分查找 第十三章：抽象和函数 ​ 本章节将介绍如何将语句组成函数，这让你能够告诉计算机如何完成任务，且只需要说一次，无需反复向计算机传达详细指令。 1. 懒惰是一种美德 前面编写的程序都很小，但如果编写大型程序，你很快就会遇到麻烦。例如：计算斐波那契数列 >>> fibs = [0,1] >>> for i in range(8): fibs.append(fibs[-2] + fibs[-1]) >>> fibs [0, 1, 1, 2, 3, 5, 8, 13, 21, 34] ​ 如果你仅想计算前十个斐波那契额数列，则上述代码正好可以满足该需求，你甚至可以微调代码用来控制其处理数据的范围，即让用户指定最终要得到的序列的长度： >>> fibs = [0,1] >>> num = int(input(\"How many Fibonacci numbers do you want?\")) How many Fibonacci numbers do you want?12 >>> num 12 >>> for i in range(num-2): fibs.append(fibs[-2] + fibs[-1]) >>> fibs [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89] 然而真正的程序员并不会这样做。真正的程序员很懒，这里的懒并不是一个贬义词，而是指不做无谓的工作。那么真正的程序员会怎样做？让程序更抽象： num = int(input(\"How many Fibonacci numbers do you want?\")) print(fibs(num)) 其中fibs就是一个函数，函数是组织好的，可重复使用的，用来实现单一，或相关联功能的代码段。 函数能提高应用的模块性，和代码的重复利用率。你已经知道Python提供了许多内建函数，比如print()。但你也可以自己创建函数，这被叫做用户自定义函数。 2. 自定义函数 ​ 抽象可以节省人力，但实际上还有更重要的优点：抽象时程序能够被人理解的关键所在。无论是编写程序还是阅读程序来说，这都至关重要。计算机通常喜欢具体而明确的指令而人通常不会是这样。 ​ 组织计算机程序时，你也可以采取类似的方式。程序应该非常的抽象，如下载网页，计算使用频率，打印每个单词的使用频率。下面将前述简单描述转换为一个Python程序： page = download_page() freqs = compute_frequencies(page) for word,freq in freqs: print(word,freq) ​ 看到这些代码，任何人都知道这个程序是做什么的。然而，至于具体该如何做，你未置一词。至于具体的操作细节，可以在其他地方（独立的函数定义）中给出。 ​ 函数执行特定的一系列操作并返回一个值，你可以通过函数名和若干参数（也可能美哟u参数）调用它。一般而言，要判断某个对象是否可被调用，可以使用内置函数callable。 >>> import math >>> x = 1 >>> y = math.sqrt >>> callable(x) False >>> callable(y) True 函数是结构化编的核心，你可以定义一个由自己想要功能的函数，以下是简单的规则： 函数代码块以 def 关键词开头，后接函数标识符名称和圆括号 ()。 任何传入参数和自变量必须放在圆括号中间，圆括号之间可以用于定义参数。 函数的第一行语句可以选择性地使用文档字符串—用于存放函数说明。 函数内容以冒号起始，并且缩进。 return [表达式] 结束函数，选择性地返回一个值给调用方。不带表达式的return相当于返回 None。 Python 定义函数使用 def 关键字，一般格式如下： def 函数名（参数列表）: 函数体 默认情况下，参数值和参数名称是按函数声明中定义的顺序匹配起来的。让我们使用函数来输出\"Hello World！\"： >>>def hello() : print(\"Hello World!\") >>> hello() Hello World! >>> 更复杂点的应用，函数中带上参数变量: #!/usr/bin/python3 # 计算面积函数 def area(width, height): return width * height def print_welcome(name): print(\"Welcome\", name) print_welcome(\"Runoob\") w = 4 h = 5 print(\"width =\", w, \" height =\", h, \" area =\", area(w, h)) 以上实例输出结果： Welcome Runoob width = 4 height = 5 area = 20 3. 函数调用 定义一个函数：给了函数一个名称，指定了函数里包含的参数，和代码块结构。 这个函数的基本结构完成以后，你可以通过另一个函数调用执行，也可以直接从 Python 命令提示符执行。 如下实例调用了 printme() 函数： #!/usr/bin/python3 # 定义函数 def printme( str ): # 打印任何传入的字符串 print (str) return # 调用函数 printme(\"我要调用用户自定义函数!\") printme(\"再次调用同一函数\") 以上实例输出结果： 我要调用用户自定义函数! 再次调用同一函数 ​ 为了在协作开发中让他人更方便的调用函数，我们要给函数编写文档，已确保他人能够理解。可添加单行注释（即以#开头的内容），也可以添加独立字符串（即使用引号括起来的内容，包括单引号，双引号和三引号）。 ​ 在有些地方，如def语句之后，以及模块和类的开头等等，添加这样的字符串很有用。放在函数开头的字符串被称为文档字符串，将作为函数的一部分存储起来，可以通过函数的 doc 属性或者特殊的内置函数help来获取有关函数的信息。 >>> form math import sqrt >>> sqrt.__doc__ 'sqrt(x)\\n\\nReturn the square root of x.' >>> help(sqrt) Help on built-in function sqrt in module math: sqrt(...) sqrt(x) Return the square root of x. 3. 参数传递 在 python 中，类型属于对象，变量是没有类型的： a=[1,2,3] a=\"Runoob\" 以上代码中，[1,2,3] 是 List 类型，\"Runoob\" 是 String 类型，而变量 a 是没有类型，她仅仅是一个对象的引用（一个指针），可以是指向 List 类型对象，也可以是指向 String 类型对象。 3.1 可更改(mutable)与不可更改(immutable)对象 在 python 中，strings, tuples, 和 numbers 是不可更改的对象，而 list,dict 等则是可以修改的对象。 不可变类型：变量赋值 a=5 后再赋值 a=10，这里实际是新生成一个 int 值对象 10，再让 a 指向它，而 5 被丢弃，不是改变a的值，相当于新生成了a。 可变类型：变量赋值 la=[1,2,3,4] 后再赋值 la[2]=5 则是将 list la 的第三个元素值更改，本身la没有动，只是其内部的一部分值被修改了。 python 函数的参数传递： 不可变类型：类似 c++ 的值传递，如 整数、字符串、元组。如fun（a），传递的只是a的值，没有影响a对象本身。比如在 fun（a）内部修改 a 的值，只是修改另一个复制的对象，不会影响 a 本身。 可变类型：类似 c++ 的引用传递，如 列表，字典。如 fun（la），则是将 la 真正的传过去，修改后fun外部的la也会受影响 python 中一切都是对象，严格意义我们不能说值传递还是引用传递，我们应该说传不可变对象和传可变对象。 3.1.1 不可变对象实例 #!/usr/bin/python3 def ChangeInt( a ): a = 10 b = 2 ChangeInt(b) print( b ) # 结果是 2 ​ 实例中有 int 对象 2，指向它的变量是 b，在传递给 ChangeInt 函数时，按传值的方式复制了变量 b，a 和 b 都指向了同一个 Int 对象，在 a=10 时，则新生成一个 int 值对象 10，并让 a 指向它。 3.1.2 可变对象实例 可变对象在函数里修改了参数，那么在调用这个函数的函数里，原始的参数也被改变了。例如： #!/usr/bin/python3 # 可写函数说明 def changeme( mylist ): \"修改传入的列表\" mylist.append([1,2,3,4]) print (\"函数内取值: \", mylist) return # 调用changeme函数 mylist = [10,20,30] changeme( mylist ) print (\"函数外取值: \", mylist) 传入函数的和在末尾添加新内容的对象用的是同一个引用。故输出结果如下： 函数内取值: [10, 20, 30, [1, 2, 3, 4]] 函数外取值: [10, 20, 30, [1, 2, 3, 4]] 4. 参数 以下是调用函数时可使用的正式参数类型： 必需参数 关键字参数 默认参数 不定长参数 4.1 必需参数 必需参数须以正确的顺序传入函数。调用时的数量必须和声明时的一样。 调用 printme() 函数，你必须传入一个参数，不然会出现语法错误： #!/usr/bin/python3 #可写函数说明 def printme( str ): \"打印任何传入的字符串\" print (str) return # 调用 printme 函数，不加参数会报错 printme() 以上实例输出结果： Traceback (most recent call last): File \"test.py\", line 10, in printme() TypeError: printme() missing 1 required positional argument: 'str' 4.2 关键字参数 关键字参数和函数调用关系紧密，函数调用使用关键字参数来确定传入的参数值有助于在调用参数时澄清各个参数的作用，虽然输入量更多了，但表达更明确更易阅读。 使用关键字参数允许函数调用时参数的顺序与声明时不一致，因为 Python 解释器能够用参数名匹配参数值。 以下实例在函数 printme() 调用时使用参数名： #!/usr/bin/python3 #可写函数说明 def printme( str ): \"打印任何传入的字符串\" print (str) return #调用printme函数 printme( str = \"菜鸟教程\") 以上实例输出结果： 菜鸟教程 以下实例中演示了函数参数的使用不需要使用指定顺序： #!/usr/bin/python3 #可写函数说明 def printinfo( name, age ): \"打印任何传入的字符串\" print (\"名字: \", name) print (\"年龄: \", age) return #调用printinfo函数 printinfo( age=50, name=\"runoob\" ) 以上实例输出结果： 名字: runoob 年龄: 50 ​ 更厉害的是，你可以结合位置参数和关键字参数，但必须先指定所有的位置参数，否则解释器可能无法知道它们究竟是哪个参数（即不知道参数对应对应什么位置，所以一般不建议同时使用位置参数和关键字参数）。 4.3 默认参数 调用函数时，如果没有传递参数，则会使用默认参数。以下实例中如果没有传入 age 参数，则使用默认值： #!/usr/bin/python3 #可写函数说明 def printinfo( name, age = 35 ): \"打印任何传入的字符串\" print (\"名字: \", name) print (\"年龄: \", age) return #调用printinfo函数 printinfo( age=50, name=\"runoob\" ) print (\"------------------------\") printinfo( name=\"runoob\" ) 以上实例输出结果： 名字: runoob 年龄: 50 ------------------------ 名字: runoob 年龄: 35 4.4 不定长参数 ​ 你可能需要一个函数能处理比当初声明时更多的参数。这些参数叫做不定长参数，和上述 2 种参数不同，声明时不会命名。基本语法如下： def functionname([formal_args,] *var_args_tuple ): \"函数_文档字符串\" function_suite return [expression] 加了星号 * 的参数会以元组(tuple)的形式导入，存放所有未命名的变量参数。 #!/usr/bin/python3 # 可写函数说明 def printinfo( arg1, *vartuple ): \"打印任何传入的参数\" print (\"输出: \") print (arg1) print (vartuple) # 调用printinfo 函数 printinfo( 70, 60, 50 ) 以上实例输出结果： 输出: 70 (60, 50) 如果在函数调用时没有指定参数，它就是一个空元组。我们也可以不向函数传递未命名的变量。如下实例： #!/usr/bin/python3 # 可写函数说明 def printinfo( arg1, *vartuple ): \"打印任何传入的参数\" print (\"输出: \") print (arg1) for var in vartuple: print (var) return # 调用printinfo 函数 printinfo( 10 ) printinfo( 70, 60, 50 ) 以上实例输出结果： 输出: 10 输出: 70 60 50 还有一种就是参数带两个星号 **基本语法如下： def functionname([formal_args,] **var_args_dict ): \"函数_文档字符串\" function_suite return [expression] 加了两个星号 ** 的参数会以字典的形式导入。 #!/usr/bin/python3 # 可写函数说明 def printinfo( arg1, **vardict ): \"打印任何传入的参数\" print (\"输出: \") print (arg1) print (vardict) # 调用printinfo 函数 printinfo(1, a=2,b=3) 以上实例输出结果： 输出: 1 {'a': 2, 'b': 3} 声明函数时，参数中星号 * 可以单独出现，例如: def f(a,b,*,c): return a+b+c 如果单独出现星号 * 后的参数必须用关键字传入。 >>> def f(a,b,*,c): ... return a+b+c ... >>> f(1,2,3) # 报错 Traceback (most recent call last): File \"\", line 1, in TypeError: f() takes 2 positional arguments but 3 were given >>> f(1,2,c=3) # 正常 6 >>> 5. 匿名函数 python 使用 lambda 来创建匿名函数。 所谓匿名，意即不再使用 def 语句这样标准的形式定义一个函数。 lambda 只是一个表达式，函数体比 def 简单很多。 lambda的主体是一个表达式，而不是一个代码块。仅仅能在lambda表达式中封装有限的逻辑进去。 lambda 函数拥有自己的命名空间，且不能访问自己参数列表之外或全局命名空间里的参数。 虽然lambda函数看起来只能写一行，却不等同于C或C++的内联函数，后者的目的是调用小函数时不占用栈内存从而增加运行效率。 lambda 函数的语法只包含一个语句，如下： lambda [arg1 [,arg2,.....argn]]:expression 如下实例： #!/usr/bin/python3 # 可写函数说明 sum = lambda arg1, arg2: arg1 + arg2 # 调用sum函数 print (\"相加后的值为 : \", sum( 10, 20 )) print (\"相加后的值为 : \", sum( 20, 20 )) 以上实例输出结果： 相加后的值为 : 30 相加后的值为 : 40 6. return语句 return [表达式] 语句用于退出函数，选择性地向调用方返回一个表达式。不带参数值的return语句返回None。之前的例子都没有示范如何返回数值，以下实例演示了 return 语句的用法： #!/usr/bin/python3 # 可写函数说明 def sum( arg1, arg2 ): # 返回2个参数的和.\" total = arg1 + arg2 print (\"函数内 : \", total) return total # 调用sum函数 total = sum( 10, 20 ) print (\"函数外 : \", total) 以上实例输出结果： 函数内 : 30 函数外 : 30 7.作用域 ​ 变量究竟是什么，可将其视为指向值的名称。因此，当执行赋值语句x=1之后，名称x指向值1.这看起来几乎和字典中的键值对完全一样，而之所以你无法察觉，只是你使用的是“看不见”的字典。实际上，这种解释已经离真相不再遥远了。Python中有一个名为vars的内置函数，它返回这个不可见字典： Python 3.6.3 (v3.6.3:2c5fed8, Oct 3 2017, 18:11:49) [MSC v.1900 64 bit (AMD64)] on win32 Type \"copyright\", \"credits\" or \"license()\" for more information. >>> x = 1 >>> scope = vars() >>> scope['x'] 1 ​ 一般而言，不应该修改vars返回的字典，因为根据Python官方文档的说法，这样做的结果是不确定的。这种不确定的字典被称为命名空间或者作用域，除全局作用域外，每个函数调用都会创建一个作用域： >>> def foo(): x = 42 >>> x 1 >>> foo() >>> x 1 ​ 以上例子中，函数foo重新定义了x的值，但当你再次查看时，它的值并没有发生改变。这是因为你在调用foo函数时，新的命名空间已经创建这个字典中值仅供当前foo函数使用，赋值语句在这个内部作用域（即局部变量）中执行是不会影响外部（全局作用域）的x。 ​ 那个既然两个同名变量互不影响，那么如何区分你调用了哪一个？这里推荐命名最好不要相同。怎样在函数中访问全局变量呢？如果名称不同，读取全局变量通常不会有问题，但还是存在出问题的可能性，比如之前的同名问题，因此，务必慎用全局变量。 8. 变量作用域 Python 中，程序的变量并不是在哪个位置都可以访问的，访问权限决定于这个变量是在哪里赋值的。 变量的作用域决定了在哪一部分程序可以访问哪个特定的变量名称。Python的作用域一共有4种，分别是： L （Local） 局部作用域 E （Enclosing） 闭包函数外的函数中 G （Global） 全局作用域 B （Built-in） 内置作用域（内置函数所在模块的范围） 以 L –> E –> G –>B 的规则查找，即：在局部找不到，便会去局部外的局部找（例如闭包），再找不到就会去全局找，再者去内置中找。 g_count = 0 # 全局作用域 def outer(): o_count = 1 # 闭包函数外的函数中 def inner(): i_count = 2 # 局部作用域 内置作用域是通过一个名为 builtin 的标准模块来实现的，但是这个变量名自身并没有放入内置作用域内，所以必须导入这个文件才能够使用它。在Python3.0中，可以使用以下的代码来查看到底预定义了哪些变量: >>> import builtins >>> dir(builtins) Python 中只有模块（module），类（class）以及函数（def、lambda）才会引入新的作用域，其它的代码块（如 if/elif/else/、try/except、for/while等）是不会引入新的作用域的，也就是说这些语句内定义的变量，外部也可以访问，如下代码： >>> if True: ... msg = 'I am from Runoob' ... >>> msg 'I am from Runoob' >>> 实例中 msg 变量定义在 if 语句块中，但外部还是可以访问的。 如果将 msg 定义在函数中，则它就是局部变量，外部不能访问： >>> def test(): ... msg_inner = 'I am from Runoob' ... >>> msg_inner Traceback (most recent call last): File \"\", line 1, in NameError: name 'msg_inner' is not defined >>> 从报错的信息上看，说明了 msg_inner 未定义，无法使用，因为它是局部变量，只有在函数内可以使用。 7.1 全局变量和局部变量 定义在函数内部的变量拥有一个局部作用域，定义在函数外的拥有全局作用域。 局部变量只能在其被声明的函数内部访问，而全局变量可以在整个程序范围内访问。调用函数时，所有在函数内声明的变量名称都将被加入到作用域中。如下实例： #!/usr/bin/python3 total = 0 # 这是一个全局变量 # 可写函数说明 def sum( arg1, arg2 ): #返回2个参数的和.\" total = arg1 + arg2 # total在这里是局部变量. print (\"函数内是局部变量 : \", total) return total #调用sum函数 sum( 10, 20 ) print (\"函数外是全局变量 : \", total) 以上实例输出结果： 函数内是局部变量 : 30 函数外是全局变量 : 0 7.2 global 和 nonlocal关键字 当内部作用域想修改外部作用域的变量时，就要用到global和nonlocal关键字了。 以下实例修改全局变量 num： #!/usr/bin/python3 num = 1 def fun1(): global num # 需要使用 global 关键字声明 print(num) num = 123 print(num) fun1() print(num) 以上实例输出结果： 1 123 123 如果要修改嵌套作用域（enclosing 作用域，外层非全局作用域）中的变量则需要 nonlocal 关键字了，如下实例： #!/usr/bin/python3 def outer(): num = 10 def inner(): nonlocal num # nonlocal关键字声明 num = 100 print(num) inner() print(num) outer() 以上实例输出结果： 100 100 另外有一种特殊情况，假设下面这段代码被运行： #!/usr/bin/python3 a = 10 def test(): a = a + 1 print(a) test() 以上程序执行，报错信息如下： Traceback (most recent call last): File \"test.py\", line 7, in test() File \"test.py\", line 5, in test a = a + 1 UnboundLocalError: local variable 'a' referenced before assignment 错误信息为局部作用域引用错误，因为 test 函数中的 a 使用的是局部，未定义，无法修改。 修改 a 为全局变量，通过函数参数传递，可以正常执行输出结果为： #!/usr/bin/python3 a = 10 def test(a): a = a + 1 print(a) test(a) 执行输出结果为： 11 9. 递归 ​ 前面主要介绍了如何创建和调用函数。我们知道，函数可以调用另一个函数，然而实际上，函数还可以调用自己。如果你以前没有遇到这种情况，可能会迷惑递归是什么意思？简单而言，递归意味着引用（这里指调用）自身。以下是一个递归式函数的定义： def recursion(): pass return recursion() ​ 这个定义显然，什么都没有做，只是不停的调用自身，就像一个死循环一样，你将发现运行一段时间后，这个程序可能会崩溃（引发异常）。每次调用函数，都会消耗一些内存当函数的调用到达一定次数，将消耗所有可用的额内存空间，导致程序被终止并显示错误消息“超过最大递归深度”。 ​ 这个函数中的递归又被称之为无穷递归，因为它理论上说永远不会结束。程序员想要的是有用的递归函数（不是空耗内存），这样的递归函数通常包含以下两部分： 基线条件（针对最小的问题）：满足某种条件时函数会直接返回一个值。 递归条件：包含一个或多个调用，这些调用旨在解决问题的一部分。 递归解决问题的关键是将问题分解成较小的部分。 9.1 阶乘和幂 ​ 本节讨论两个经典的递归函数。首先，假设你要计算数字n的阶乘，比如你要计算将n个人排成一队共有多少种方式，可使用循环来实现： def factorial(n): result = n for i in range(1,n): result *= i return reault ​ 这种实现方式无疑是可行的，而且直截了当。大致而言，程序的流程是这样的： 先将result的值设置为n; 再将result依次乘以1到n-1之间的每一个数字； 最后返回result。 在数学方面，阶乘的定义可表述如下： 1的阶乘等于1 对于大于1的数字n，其阶乘为n-1的阶乘再乘以n 那么，我们可以定义如下的函数： def factorial(n): if(n == 1): return 1 else: return factorial(n-1) * n print(factorial(5)) 再来看一个实例，假设你要计算幂，就像内置函数pow和运算符**所作的那样定义一个power： def power(x,n): if(n = 0): return 1 else: result = 1 for i in range(n): result *= x return result 这是一个非常简单的小型函数，但依然可以将其改为递归式的 对于任何数字x,power（x,1）都为1 当n>0时，power(x,n)为power(x,n-1)与x的乘积 def power(x,n): if(n = 0): return 1 else: return power(x,n-1) * x ​ 那么使用递归有什么意义呢？同样的效果使用循环也可以实现。而且在大多数情况下，使用循环的效率可能更高。但是，在很多时候，使用递归的可阅读性更高，在你理解函数的递归式定义尤其如此。另外，虽然你完全可以避免使用递归机型编程，但作为程序员必须能够读懂他人编写的递归算法和函数。 9.2 二分查找 首先分解以下二分查找的实现： 如果查找上限和下限相同，则其均指向查找元素，直接返回该元素 如果上下限并不一致，则取上下限平均值的中间值，再确认查找元素时在上半部分还是下半部分，然后再继续在新的范围内查找 对于数字的二分查找，需要先排序，以下为一个二分查找数字的简单例子： def search(squence, number, lower, upper): if(lower == upper): assert number = squence[upper] return upper else: middle = (lower + upper)/2 if(number > middle): return search(squence, number, middle, upper) else: return search(squence, number, lower, middle) 实际上，python中bisect模块提供了标准的二分查找实现。 MU_zjm®Designer, Developer & overall web enthusiastCopyright © MU_zjm all right reserved, powered by MU_zjm!created by MU_zjm 2019-08-28 12:00:00 "},"Python/Chapter14.html":{"url":"Python/Chapter14.html","title":"第十四章：抽象和对象","keywords":"","body":"TreeviewCopyright © all right reserved, powered by aleen42 第十四章：抽象和对象 1. 面向对象技术简介 2. 多态 3.封装 4.继承 5. 多继承 6. 类 7. 类的方法 8. 方法重写 9. 类属性与方法 9.1 类的私有属性 9.2 类的方法 9.3 类的私有方法 实例 9.4 类的专有方法： 10. 运算符重载 第十四章：抽象和对象 Python从设计之初就已经是一门面向对象的语言，正因为如此，在Python中创建一个类和对象是很容易的。本章节我们将详细介绍Python的面向对象编程，以及如何创建自定义对象。 如果你以前没有接触过面向对象的编程语言，那你可能需要先了解一些面向对象语言的一些基本特征，在头脑里头形成一个基本的面向对象的概念，这样有助于你更容易的学习Python的面向对象编程。 1. 面向对象技术简介 在面向对象编程中，对象大致意味着一系列数据（属性）以及一套访问和操作这些数据的方法。 类(Class): 用来描述具有相同的属性和方法的对象的集合。它定义了该集合中每个对象所共有的属性和方法。对象是类的实例。 方法：类中定义的函数。 类变量：类变量在整个实例化的对象中是公用的。类变量定义在类中且在函数体之外。类变量通常不作为实例变量使用。 数据成员：类变量或者实例变量用于处理类及其实例对象的相关的数据。 方法重写：如果从父类继承的方法不能满足子类的需求，可以对其进行改写，这个过程叫方法的覆盖（override），也称为方法的重写。 局部变量：定义在方法中的变量，只作用于当前实例的类。 实例变量：在类的声明中，属性是用变量来表示的。这种变量就称为实例变量，是在类声明的内部但是在类的其他成员方法之外声明的。 继承：即一个派生类（derived class）继承基类（base class）的字段和方法。继承也允许把一个派生类的对象作为一个基类对象对待。例如，有这样一个设计：一个Dog类型的对象派生自Animal类，这是模拟\"是一个（is-a）\"关系（例图，Dog是一个Animal）。 实例化：创建一个类的实例，类的具体对象。 对象：通过类定义的数据结构实例。对象包括两个数据成员（类变量和实例变量）和方法。 和其它编程语言相比，Python 在尽可能不增加新的语法和语义的情况下加入了类机制。 ​ Python中的类提供了面向对象编程的所有基本功能：类的继承机制允许多个基类，派生类可以覆盖基类中的任何方法，方法中可以调用基类中的同名方法。 对象可以包含任意数量和类型的数据。 使用对象而非全局变量和函数的原因有多个，下面列出了使用对象最重要的好处： 多态：可对不同类型的对象执行相同的操作，而这些操作就像“被施了魔法”一样能够正常运行。 封装：对外界隐藏有关对象工作原理的细节 继承：可基于通用类创建出专用类 在很多介绍面向对象编程的资料中，都以不同于这里的顺序介绍上述概念。一般先介绍封装和继承，再使用这些概念来模拟现实世界的对象。这没什么不好，但是在我看来，多态才是面向对象编程最有趣的事情。而一般而言，这也是让大多数人感到迷惑的特性。 2. 多态 ​ 多态源自于希腊语，意思是“有多种形态”。这大致意味着你即使不知道变量指向的是那种对象，也能对齐执行操作，且操作的行为将随对象所属的具体类型（类）而异。 ​ 一个简单的查询价格可能根据不同的查询方式和实现方法而重新设计实现，这样可能会开发多次，甚至推翻之前已有的代码。如何避免这样的问题？在面向对象编程中，我们使用多态来解决，即让对象自己处理对应的操作。无论有多少种新对象，都能够正确的获取并计算其价格返回，而用户只需要向它查询价格即可，这正是多态的用武之地。 ​ 你收到一个对象，却根本不知道它是如何实现的-- --他可能是众多“形态”中的任何一种。如果你知道它可以查询价格，这就够了，像这样与对象属性相关联的函数又被称为方法。 ​ 下面来做一个实验。标准库模块random中包含一个choice的函数，它从序列中随机选择一个元素： Python 3.6.3 (v3.6.3:2c5fed8, Oct 3 2017, 18:11:49) [MSC v.1900 64 bit (AMD64)] on win32 Type \"copyright\", \"credits\" or \"license()\" for more information. >>> from random import choice >>> arr = ['hello,world!',[1,2,'e','e','e']] >>> choice(arr).count('e') 3 >>> choice(arr).count('e') 1 >>> ​ 以上例子表明，你无需关心随机选取的是一个什么类型的数据，你可以只关心它之中到底有几个‘e’即可，为了这一目的，你可以调count，即可得到你要的答案。 ​ 当你无需知道对象是什么样的就能对其执行操作，就是多态在起作用。这不仅适用于方法，我们还通过内置运算符和函数大量使用了多态。例如： >>> 1 + 1 2 >>> 'a ' + 'b' 'a b' ​ 以上代码表明，加法运算符既可用于数，也可用于字符串，以及其他类型的序列。加法运算符两边的值可以是任何支持加法的对象。如果要编写一个函数，通过打印一条消息来指定对象长度，你可以这么做： >>> def length_message(x): print(\"The length of \" + repr(x),' is ',len(x)) 如你所见，这个函数还使用了repr。repr是Python中多态的集大成者之一，可以用于任对象，下面就来看看： >>> length_message(\"Fnord\") The length of 'Fnord' is 5 >>> length_message([1,2,3]) The length of [1, 2, 3] is 3 ​ 这里讨论的多态形式是Python编程方式的核心，有时也被称为鸭子模型，这个术语源自于如下说法：“如果走起来像鸭子，叫起来像鸭子，那么它就是鸭子。” 3.封装 ​ 封装（encapsulation）指的是向外部隐藏不必要的细节。这听起来很像多态（无需知道对象内部的细节就可以使用它）。这两个对象很像，因为它们都是抽象的原则。它们都像函数一样，可以帮助你处理程序的组成部分，让你无需关心不必要的细节。 ​ 但封装不同于多态。多态让你无需知道对象所属的类（对象的类型）就能调用其方法，而封装让你无需知道对象的构造就能使用它。如果还是不明白，还是来一个例子吧，假设你有一个名为OpenObject的类： >>>o = OpenObject() #对象就是这么建立的 >>>o.set_name(\"Sir Lacelot\") >>>o.get_name() Sir Lacelot 4.继承 Python 同样支持类的继承，如果一种语言不支持继承，类就没有什么意义。派生类的定义如下所示: class DerivedClassName(BaseClassName1): . . . ​ 需要注意圆括号中基类的顺序，若是基类中有相同的方法名，而在子类使用时未指定，python从左至右搜索 即方法在子类中未找到时，从左到右查找基类中是否包含方法。 ​ BaseClassName（示例中的基类名）必须与派生类定义在一个作用域内。除了类，还可以用表达式，基类定义在另一个模块中时这一点非常有用: class DerivedClassName(modname.BaseClassName): #!/usr/bin/python3 #类定义 class people: #定义基本属性 name = '' age = 0 #定义私有属性,私有属性在类外部无法直接进行访问 __weight = 0 #定义构造方法 def __init__(self,n,a,w): self.name = n self.age = a self.__weight = w def speak(self): print(\"%s 说: 我 %d 岁。\" %(self.name,self.age)) #单继承示例 class student(people): grade = '' def __init__(self,n,a,w,g): #调用父类的构函 people.__init__(self,n,a,w) self.grade = g #覆写父类的方法 def speak(self): print(\"%s 说: 我 %d 岁了，我在读 %d 年级\"%(self.name,self.age,self.grade)) s = student('ken',10,60,3) s.speak() 执行以上程序输出结果为： ken 说: 我 10 岁了，我在读 3 年级 5. 多继承 Python同样有限的支持多继承形式。多继承的类定义形如下例: class DerivedClassName(Base1, Base2, Base3): . . . 需要注意圆括号中父类的顺序，若是父类中有相同的方法名，而在子类使用时未指定，python从左至右搜索 即方法在子类中未找到时，从左到右查找父类中是否包含方法。 #!/usr/bin/python3 #类定义 class people: #定义基本属性 name = '' age = 0 #定义私有属性,私有属性在类外部无法直接进行访问 __weight = 0 #定义构造方法 def __init__(self,n,a,w): self.name = n self.age = a self.__weight = w def speak(self): print(\"%s 说: 我 %d 岁。\" %(self.name,self.age)) #单继承示例 class student(people): grade = '' def __init__(self,n,a,w,g): #调用父类的构函 people.__init__(self,n,a,w) self.grade = g #覆写父类的方法 def speak(self): print(\"%s 说: 我 %d 岁了，我在读 %d 年级\"%(self.name,self.age,self.grade)) #另一个类，多重继承之前的准备 class speaker(): topic = '' name = '' def __init__(self,n,t): self.name = n self.topic = t def speak(self): print(\"我叫 %s，我是一个演说家，我演讲的主题是 %s\"%(self.name,self.topic)) #多重继承 class sample(speaker,student): a ='' def __init__(self,n,a,w,g,t): student.__init__(self,n,a,w,g) speaker.__init__(self,n,t) test = sample(\"Tim\",25,80,4,\"Python\") test.speak() #方法名同，默认调用的是在括号中排前地父类的方法 执行以上程序输出结果为： 我叫 Tim，我是一个演说家，我演讲的主题是 Python 6. 类 语法格式如下： class ClassName: . . . 类实例化后，可以使用其属性，实际上，创建一个类之后，可以通过类名访问其属性。 类对象支持两种操作：属性引用和实例化。 属性引用使用和 Python 中所有的属性引用一样的标准语法：obj.name。 类对象创建后，类命名空间中所有的命名都是有效属性名。所以如果类定义是这样: #!/usr/bin/python3 class MyClass: \"\"\"一个简单的类实例\"\"\" i = 12345 def f(self): return 'hello world' # 实例化类 x = MyClass() # 访问类的属性和方法 print(\"MyClass 类的属性 i 为：\", x.i) print(\"MyClass 类的方法 f 输出为：\", x.f()) 以上创建了一个新的类实例并将该对象赋给局部变量 x，x 为空的对象。 执行以上程序输出结果为： MyClass 类的属性 i 为： 12345 MyClass 类的方法 f 输出为： hello world 类有一个名为 init() 的特殊方法（构造方法），该方法在类实例化时会自动调用，像下面这样： def init(self): self.data = [] 类定义了 init() 方法，类的实例化操作会自动调用 init() 方法。如下实例化类 MyClass，对应的 init() 方法就会被调用: x = MyClass() 当然， init() 方法可以有参数，参数通过 init() 传递到类的实例化操作上。例如: #!/usr/bin/python3 class Complex: def __init__(self, realpart, imagpart): self.r = realpart self.i = imagpart x = Complex(3.0, -4.5) print(x.r, x.i) # 输出结果：3.0 -4.5 self代表类的实例，而非类 类的方法与普通的函数只有一个特别的区别——它们必须有一个额外的第一个参数名称, 按照惯例它的名称是 self。 class Test: def prt(self): print(self) print(self.__class__) t = Test() t.prt() 以上实例执行结果为： __main__.Test 从执行结果可以很明显的看出，self 代表的是类的实例，代表当前对象的地址，而 self.class 则指向类。 self 不是 python 关键字，我们把他换成 runoob 也是可以正常执行的: class Test: def prt(runoob): print(runoob) print(runoob.__class__) t = Test() t.prt() 以上实例执行结果为： __main__.Test 7. 类的方法 在类的内部，使用 def 关键字来定义一个方法，与一般函数定义不同，类方法必须包含参数 self, 且为第一个参数，self 代表的是类的实例。 #!/usr/bin/python3 #类定义 class people: #定义基本属性 name = '' age = 0 #定义私有属性,私有属性在类外部无法直接进行访问 __weight = 0 #定义构造方法 def __init__(self,n,a,w): self.name = n self.age = a self.__weight = w def speak(self): print(\"%s 说: 我 %d 岁。\" %(self.name,self.age)) # 实例化类 p = people('runoob',10,30) p.speak() 执行以上程序输出结果为： runoob 说: 我 10 岁。 8. 方法重写 如果你的父类方法的功能不能满足你的需求，你可以在子类重写你父类的方法，实例如下： #!/usr/bin/python3 class Parent: # 定义父类 def myMethod(self): print ('调用父类方法') class Child(Parent): # 定义子类 def myMethod(self): print ('调用子类方法') c = Child() # 子类实例 c.myMethod() # 子类调用重写方法 super(Child,c).myMethod() #用子类对象调用父类已被覆盖的方法 super() 函数是用于调用父类(超类)的一个方法。 执行以上程序输出结果为： 调用子类方法 调用父类方法 9. 类属性与方法 9.1 类的私有属性 __private_attrs：两个下划线开头，声明该属性为私有，不能在类的外部被使用或直接访问。在类内部的方法中使用时 self.__private_attrs。 9.2 类的方法 在类的内部，使用 def 关键字来定义一个方法，与一般函数定义不同，类方法必须包含参数 self，且为第一个参数，self 代表的是类的实例。 self 的名字并不是规定死的，也可以使用 this，但是最好还是按照约定是用 self。 9.3 类的私有方法 __private_method：两个下划线开头，声明该方法为私有方法，只能在类的内部调用 ，不能在类的外部调用。self.__private_methods。 实例 类的私有属性实例如下： #!/usr/bin/python3 class JustCounter: __secretCount = 0 # 私有变量 publicCount = 0 # 公开变量 def count(self): self.__secretCount += 1 self.publicCount += 1 print (self.__secretCount) counter = JustCounter() counter.count() counter.count() print (counter.publicCount) print (counter.__secretCount) # 报错，实例不能访问私有变量 执行以上程序输出结果为： 1 2 2 Traceback (most recent call last): File \"test.py\", line 16, in print (counter.__secretCount) # 报错，实例不能访问私有变量 AttributeError: 'JustCounter' object has no attribute '__secretCount' 类的私有方法实例如下： #!/usr/bin/python3 class Site: def __init__(self, name, url): self.name = name # public self.__url = url # private def who(self): print('name : ', self.name) print('url : ', self.__url) def __foo(self): # 私有方法 print('这是私有方法') def foo(self): # 公共方法 print('这是公共方法') self.__foo() x = Site('菜鸟教程', 'www.runoob.com') x.who() # 正常输出 x.foo() # 正常输出 x.__foo() # 报错 以上实例执行结果： 9.4 类的专有方法： init : 构造函数，在生成对象时调用 del : 析构函数，释放对象时使用 repr : 打印，转换 setitem : 按照索引赋值 getitem: 按照索引获取值 len: 获得长度 cmp: 比较运算 call: 函数调用 add: 加运算 sub: 减运算 mul: 乘运算 truediv: 除运算 mod: 求余运算 pow: 乘方 10. 运算符重载 Python同样支持运算符重载，我们可以对类的专有方法进行重载，实例如下： #!/usr/bin/python3 class Vector: def __init__(self, a, b): self.a = a self.b = b def __str__(self): return 'Vector (%d, %d)' % (self.a, self.b) def __add__(self,other): return Vector(self.a + other.a, self.b + other.b) v1 = Vector(2,10) v2 = Vector(5,-2) print (v1 + v2) 以上代码执行结果如下所示: Vector(7,8) MU_zjm®Designer, Developer & overall web enthusiastCopyright © MU_zjm all right reserved, powered by MU_zjm!created by MU_zjm 2019-08-28 12:00:00 "},"Python/Chapter15.html":{"url":"Python/Chapter15.html","title":"第十五章：异常","keywords":"","body":"第十五章：异常 MU_zjm®Designer, Developer & overall web enthusiastCopyright © MU_zjm all right reserved, powered by MU_zjm!created by MU_zjm 2019-08-28 12:00:00 "}}