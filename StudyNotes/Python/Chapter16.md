# 第十六章：开箱即用

​		Python不仅语言核心十分强大，还提供了其他工具以供使用。标准安装包含一组称为标注库（standard library）的模块，你见过其中的一些（如math和cmath），但还有其他很多。

## 1. 模块

你已经知道如何创建和执行程序（或脚本），还知道如何使用import将函数从外部模块导入到程序中。

```powershell
>>> import math
>>>	math.sin(0)
0.0
```

下面来看看如何编写自己的模块

### 1.1 模块就是程序

​		任何Python程序都可作为模块导入。假设你编写了一个简单的helloworld程序，并将其保存在文件hello.py中，这个文件的名称（不包含扩展名.py）将成为模块的名称。

```
#hello.py
print("Hello,World!")
```

​		文件的存储位置也很重要。这里假设这个文件存储在目录C:\python(Windows)~/python(UNIX/macOS)中。要告诉解释器去哪里查找这个模块，可执行如下命令（以Windows目录为例）：

```
>>> import sys
>>> sys.path.append('C:/python')
```

**提示**：在UNIX中，不能直接将字符串'~/python'附加到sys.path末尾，而必须使用完成的路径（如’/home/yourusername/python‘）。如果你要自动创建完整的路径，可使用sys.path.expanduser('~/python')。

这告诉解释器，除了通常将查找的位置外，还应到目录C:\python中查找这个模块。这样做后，就可以导入这个模块（它存储在文件C:\python\hello.py）。

```powershell
>>> import hello
Hello,World!
```

**注意**：当你导入模块时，可能会发现其所在目录中除源代码文件外，还新建了一个名为_ _ pycache _ _的子目录（在旧版本的Python中，是扩展名为.pyc的文件）。这个目录包含处理过后的文件，Python能够更高效地处理它们。以后再导入这个模块时，如果.py文件未发生变化，Python将导入处理后的文件，否则将重新生成处理后的文件。删除目录_ _ _ pacache _  _不会有任何坏处，因为必要时会重新创建它。

​		如你所示，导入这个模块时，执行了其中的代码。但是如果再次导入它，什么事情都不会发生。为何没有再执行其中的代码呢？因为模块并不是用来执行操作（如打印文本）的，而是用于**定义**变量，函数，类等。鉴于定义只需要做一次，因此导入模块多次和导入一次的效果相同。

## 1.2 为何只导入一次

​		在大多数情况下，只导入一次是重要的优化，且在下述特殊情况下显得尤为专业：两个模块彼此导入对方。

​		在很多情况下，你可能编写两个这样的模块：需要彼此访问对方的函数和类才能正确的发挥作用。例如，你可能创建了两个模块clientdb和billing，分别包含客户数据库和记账系统的代码。客户数据库可能包含对记账系统的调用（如每月自动向客户发送账单），而记账系统可能需要访问客户数据库的功能才能正确的完成记账。

​		在这里，如果每个模块都可导入多次，就会出现问题。模块clientdb导入binding，而binding又导入clientdb，结果可想而知：最终将形成无穷的导入循环（还记得无穷递归么？）。然而，由于第二次导入什么都不会发生，这种循环被打破。

​		而如果一定要重新加载模块，可使用模块importlib中的函数reload，它接受一个此参数（要重新加载的模块），并返回重新加载的模块。如果在程序运行时修改了模块，并希望这种修改反映到程序中，这将很有用。要重新加载前述简单的模块hello，可像下面这样做：

```powershell
>>> import importlib
>>> hello = importlib.reload(hello)
Hello,world!
```

​		这里假设hello已导入（一次）。通过将函数reload的结果赋给hello，用重新加载的版本替换了以前的版本。由于打印出了问候语，说明这里确实是导入了这个模块。

​		通过实例化模块bar中的类Foo创建对象x后，如果重新加载模块bar，并不会重新重新创建x指向的对象，即x依然是（来自旧版bar的）旧版Foo的对象。要让x指向基于重新加载的模块中的Foo创建的对象，需要重新创建它。

## 1.3 模块是用来下定义的

​		模块是首次导入程序时执行。这看似有点用，但是用处不大。让模块值得被创建的原因在于它们像类一样，有自己的作用域。这意味着模块中定义的类和函数以及对其进行赋值的变量都将成为模块的属性。

### 1.3.1 在模块中定义函数

​		假设你编写了一个简单的模块，并将其存储在文件hello2.py中。另外，假设你将这个文件放在Python解释器能够找到的地方。模块代码如下：

```
#hello2.py
def hello():
	print('Hello,World!')
```

​		现在可以像下面这样导入它：

```
>>>import hello2
```

​		这将会执行这个模块，也就是说这个模块的作用域内定义函数hello，因此可以像下面这样访问这个函数：

```
>>>hello2.hello()
Hello,World!
```

​		在模块的全局作用域内定义的名称都可像上面这样访问。为何要这样做呢？为何不在主程序中定义一切呢？主要还是为了**代码重用**。通过将代码放到模块中，就可在多个程序中使用它们。这意味着如果你编写了一个出色的客户端数据库，并将其放在模块clientdb中，就可在记账时以及任何需要访问客户数据的程序中使用它。如果没有放在独立的模块中，就需要每个这样的程序中重新编写它。因此，要让代码是可重用的，务必将其模块化，这也与抽象密切相关。

### 1.3.2 在模块中添加测试代码

​		模块用于定义函数和类等，但是有些情况下（实际上是经常），添加一些测试代码来检查情况是否符合预期且很有用。例如，如果要确认函数hello管用，你可能将模块hello2重写为代码：

```python
#hello3.py
def hello():
	print('Hello,World!')
	
# 测试
hello()
```

​		这看似合理：如果将这个模块作为普通程序运行，将发现它运行正常。然而，如果在另一个程序中将其作为模块导入，以便能够使用函数hello，也将默认执行该测试代码，就像第一个hello模块一样。

```powershell
>>>import hello3
Hello,World!
>>>hello3.hello()
Hello,World!
```

​		这样的效果一般不是预期的结果。要避免这种行为，关键在于检查模块是作为程序运行还是被导入另一个程序。为此，需要使用变量_ _ name _  _ 。

```powershell
>>> __name__
'__main__'
>>>hello3.__name__
'hello3'
```

​		如你所见，在主程序中（包括解释器的交互式提示符），变量_ _ name _ _ 的值是‘_ _ main _ _ ’，而在导入的模块中，这个变量被设置为该模块的名称。因此，要让模块中的测试代码的行为更合理，可将其放在一条if语句中，一个包含有条件地执行地测试代码的模块如下所示：

```python
# hello4.py

def hello():
	print('Hello,World!')
	
def test():
	hello()

if __name__ == '__main__':
	test()
```

​		如果将这个模块作为程序运行，将执行函数hello；如果导入它，，其行为将更像普通模块一样。

```powershell
>>>import hello4
>>>hello4.hello()
Hello,World!
```

​		如你所见，我将测试代码放在了test中。原本可以将这些代码直接放在if语句中但通过将其放在一个独立的测试函数中，可在程序中导入模块并对其进行测试。

```powershell
>>>hello4.test()
Hello,World!
```

​		如果要编写更详尽的测试代码，将其放在一个独立的程序可能是个不错的主意。

### 1.3.3 让模块可用

​		在前面的示例中，我修改了sys.path。sys.path包含了一个目录（表示为字符串）列表，解释器将在这些目录中查找模块。然而，通常你不想这样做。最理想的情况是sys.path一开始就包含正确的目录（你的模块所在的目录）。为此有两种办法：1，将模块放在正确的位置；2，告诉编译器到哪里去查找。接下来的两节将分别讨论这两种解决方案。如果要让别人能够轻松使用你的模块，那就是另外一码事了。Python打包技术一度日益复杂，各自为政，尽管现已被Python Packaging Authority控制并简化，但需要学习的还是有很多。这里不深入介绍这个棘手的主题，建议参阅“Python打包用户指南”：packaging.python.org。

#### 1.3.3.1 将模块放在正确的位置

​		将模块放在正确的位置很容易，只需要找出Python解释器到哪里去查找模块，再将文件放在这些地方即可。在你使用的计算机中，如果Python解释器是管理员安装的，而你没有管理员权限，就可能无法将模块保存在Python使用的目录中，则需要使用方法二。

​		你可能还记得，可在模块sys的变量python中找到目录列表（即搜索路径）。

```powershell
>>> import sys,pprint
>>> pprint.pprint(sys.path)
['',
 'C:\\Users\\AppData\\Local\\Programs\\Python\\Python36\\Lib\\idlelib',
 'C:\\Users\\AppData\\Local\\Programs\\Python\\Python36\\python36.zip',
 'C:\\Users\\AppData\\Local\\Programs\\Python\\Python36\\DLLs',
 'C:\\Users\\AppData\\Local\\Programs\\Python\\Python36\\lib',
 'C:\\Users\\AppData\\Local\\Programs\\Python\\Python36',
 'C:\\Users\\AppData\\Local\\Programs\\Python\\Python36\\lib\\site-packages']
```

**提示**：如果要打印的数据结构太大，一行容不下，可使用模块pprint中的函数pprint（而不是普通的print语句）。pprint是一个卓越的打印函数，能够更妥善的打印输出。

​		当然，你得到的打印结果可能与这里显示的不完全相同。这里的要点是，每个字符串都表示一个位置，如果要让解释器找到这些模块，可将其放在任何一个位置中。虽然放在这里显示的任何一个位置都行，但目录site-packages是最佳的选择，因为它就是用来放置模块的。请在计算机中查看sys.path，找到目录site-packages，并将模块保存在这里。

​		只要模块位于类似于site-packages这样的地方，所有程序就都能导入它。

#### 1.3.3.2 告诉解释器去哪里查找

​		将模块放在正确的位置可能不是合适的解决方案，其中原因有很多：

- 不希望Python解释器的目录中充斥着你编写的模块；

- 没有必要的权限，无法将文件保存在Python解释器的目录中；

- 像将模块放在其他地方；

​		最重要的是，如果将模块放在其他地方，就必须告诉解释器去哪里查找。前面说过，要告诉解释器去哪里去查找模块，办法之一是直接修改sys.path，但这种做法不常见。标准做法是将模块所属的目录包含在环境变量PYTHONPATH中。

​		环境变量PYTHONPATH中的内容随操作系统而异，但它基本上类似于sys.path，也是一个目录列表。环境变量并不是Python解释器的一部分，而是操作系统的一部分。大致而言，它们类似于Python变量，但是在Python解释器外面设置的。

​		如果你使用的是bash shell（在大多数类UNIX系统，macOS和较新的Windows版本中都有），就可以使用如下命令将'~/python'附加到环境变量PYTHONPATH末尾：

```powershell
export PYTHONPATH=$PYTHONPATH:~/python
```

​		如果要对所有启动的shell都执行这个命令，可将其添加到主目录中的.bashrc文件中。

​		除使用环境变量PYTHONPATH外，还可以使用路径配置文件，这些文件的扩展名为.pth，位于一些特殊目录中，包含在要添加到sys.path中的目录。

### 1.3.4 包

​		为组织模块，可将其编组为包（package）。包其实就是另一种模块，但有趣的是它们可包含其他的模块。模块存储在扩展名为.py的文件中，而包则是一个目录。要被Python视为包，目录必须包含文件_ _ init _ _.py。如果像普通模块一样导入包，文件_ _ init _ _.py的内容就将是包的内容。例如，如果有一个名为constants的包，而文件constants/_ _ init _ _.py包含语句PI = 3.14，就可以像下面这样做：

```python
import constants
print(constants.PI)
```

​		要将模块加入包中，只需将模块文件放在包目录中即可。你还可以在包中嵌入其他包。例如，要创建一个名为drawing的包，其中包含模块shapes和colors，需要创建如下所示的文件和目录（UNIX路径）：

|            文件/目录             |        描  述         |
| :------------------------------: | :-------------------: |
|            ~/python/             |  PYTHONPATH中的目录   |
|        ~/python/drawing/         |  包目录（包drawing）  |
| ~/python/drawing/_ _ init _ _.py | 包代码（模块drawing） |
|    ~/python/drawing/colors.py    |      模块colors       |
|    ~/python/drawing/shapes.py    |      模块shapes       |

​		完成以上这些准备工作后，下面的语句都是合法的：

```python
import drawing				#（1）导入drawing包
import drawing.colors		#（2）导入drawing包中的模块colors
from drawing import shapes	#（3）导入模块shapes
```

​		执行第一条语句后，便可以使用目录drawing中文件_ _ init _ _.py的内容，但是不能使用模块shapes和colors的内容。执行第二条语句后便可以使用模块colors，但只能通过全限定名drawing.colors来使用。执行第三条语句，便可以使用简化名（即shapes）来使用模块shapes。

​		请注意，这些语句只是实例，并不用像这里做的那样，先导入包再导入其中的模块，换而言之，完全可以只是单独使用第二条或第三条语句。

## 2. 探索模块

​		介绍一些标准库模块之前，先说说如何探索这些模块，这是一个很有用的技能，因为在你的Python程序员职业生涯中，将遇到很多很有用的模块，而这里无法一一介绍。当前的标准库很大，足以编写专著来论述（市场上也的确有这样的专著），而且还在不断增大。

​		每个新Python版本都新增了模块，通常还会对一些既有模块进行细微的修改和改进。另外，你在网上肯定会找到一些有用的模块。如果能快速而轻松地理解它们，编程工作将有趣的多。

### 2.1 模块包含什么

​		要探索模块，最直接地方法就是使用Python解释器进行研究。为此，首先需要将模块导入。假设你听说有一个名为copy的标准模块。

```
>>>import copy
```

​		没有引发异常，说明的确有这样的模块。但这个模块是做什么用的？它都包含些什么？